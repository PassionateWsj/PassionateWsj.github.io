<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="简单即快乐。">
<meta property="og:type" content="website">
<meta property="og:title" content="JamesWong&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="JamesWong&#39;s Notes">
<meta property="og:description" content="简单即快乐。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JamesWong&#39;s Notes">
<meta name="twitter:description" content="简单即快乐。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>JamesWong's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JamesWong's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/Retrofit-更换-host & Retrofit-离线缓存 & WebView 离线缓存 & X5 WebView 滑动冲突 和 滚动条/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/Retrofit-更换-host & Retrofit-离线缓存 & WebView 离线缓存 & X5 WebView 滑动冲突 和 滚动条/" itemprop="url">2018-01-22 Retrofit 更换 host</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T10:11:15+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li><p>动态改变 Retrofit 网络请求中的服务器连接</p>
<ul>
<li><p>添加一个允许运行时改变 hostname 的拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ChangeableBaseUrlInterceptor : Interceptor &#123;</span><br><span class="line">    @Volatile private var host: HttpUrl? = null</span><br><span class="line"></span><br><span class="line">    fun setHost(url: String) &#123;</span><br><span class="line">        this.host = HttpUrl.parse(url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Throws(IOException::class)</span><br><span class="line">    override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">         val newRequest = host?.let &#123;</span><br><span class="line">            val newUrl = chain.request().url().newBuilder()</span><br><span class="line">                    .scheme(it.scheme())</span><br><span class="line">                    .host(it.url().toURI().host)</span><br><span class="line">                    .port(it.port())</span><br><span class="line">                    .build()</span><br><span class="line"></span><br><span class="line">            return@let chain.request().newBuilder()</span><br><span class="line">                    .url(newUrl)</span><br><span class="line">                    .build()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         return if(newRequest!=null)&#123;</span><br><span class="line">             chain.proceed(newRequest)</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             chain.proceed(chain.request())</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Retrofit 离线缓存</p>
<ol>
<li><p>设置缓存路径</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder();</span><br><span class="line"></span><br><span class="line">File cacheDir = new File(ctx.getCacheDir(), &quot;response&quot;);</span><br><span class="line">//缓存的最大尺寸10m</span><br><span class="line">Cache cache = new Cache(cacheDir, 1024 * 1024 * 10);</span><br><span class="line">clientBuilder.cache(cache);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>2. 添加拦截器

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class CacheInterceptor : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    override fun intercept(chain: Interceptor.Chain): okhttp3.Response &#123;</span><br><span class="line">        var request = chain.request()</span><br><span class="line">        val netAvailable = HttpUtil.isConnected(SYPApplication.globalContext)</span><br><span class="line"></span><br><span class="line">        if (netAvailable) &#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    //网络可用 强制从网络获取数据</span><br><span class="line">                    .cacheControl(CacheControl.FORCE_NETWORK)</span><br><span class="line">                    .build()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    //网络不可用 从缓存获取</span><br><span class="line">                    .cacheControl(CacheControl.FORCE_CACHE)</span><br><span class="line">                    .build()</span><br><span class="line">        &#125;</span><br><span class="line">        var response = chain.proceed(request)</span><br><span class="line">        if (netAvailable) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    // 有网络时 设置缓存超时时间1个小时</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public, max-age=&quot; + 60 * 60)</span><br><span class="line">                    .build()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    // 无网络时，设置超时为1周</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale=&quot; + 7 * 24 * 60 * 60)</span><br><span class="line">                    .build()</span><br><span class="line">        &#125;</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>WebView 离线缓存</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">webSettings?.cacheMode = if (HttpUtil.isConnected(this)) &#123;</span><br><span class="line">    // 缓存模式为无缓存</span><br><span class="line">    WebSettings.LOAD_NO_CACHE</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    WebSettings.LOAD_CACHE_ELSE_NETWORK</span><br><span class="line">&#125;</span><br><span class="line">val cacheDir = File(cacheDir, &quot;webviewCache&quot;)</span><br><span class="line">//设置数据库缓存路径</span><br><span class="line">webSettings?.databasePath = cacheDir.absolutePath</span><br><span class="line">//设置 应用 缓存目录</span><br><span class="line">webSettings?.setAppCachePath(cacheDir.absolutePath)</span><br><span class="line">//开启 DOM 存储功能</span><br><span class="line">webSettings?.domStorageEnabled = true</span><br><span class="line">//开启 数据库 存储功能</span><br><span class="line">webSettings?.databaseEnabled = true</span><br><span class="line">//开启 应用缓存 功能</span><br><span class="line">webSettings?.setAppCacheEnabled(true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>X5 的 WebView 与 SwipeRefreshLayout 滑动冲突</p>
<ul>
<li><p>注意 : <code>this.getScrollY()</code> 永远为 0 ，想要获取 WebView 顶部到 WebView 可视顶部距离的方法为 <code>this.getWebScrollY()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 重写 WebView 的onScrollChagned 方法</span><br><span class="line">public class WebView4Scroll extends WebView &#123;</span><br><span class="line">    private SwipeRefreshLayout swipeRefreshLayout;</span><br><span class="line"></span><br><span class="line">    public WebView4Scroll(Context context, SwipeRefreshLayout swipeRefreshLayout)&#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.swipeRefreshLayout = swipeRefreshLayout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123;</span><br><span class="line">        super.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line">        if (this.getWebScrollY() == 0)&#123;</span><br><span class="line">            swipeRefreshLayout.setEnabled(true);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            swipeRefreshLayout.setEnabled(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>X5 的 WebView 去除滚动条</p>
<pre><code>mWebView?.x5WebViewExtension?.setScrollBarFadingEnabled(false)
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/17/2018-01-13-Kotlin关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/17/2018-01-13-Kotlin关键字/" itemprop="url">2018-01-17 Kotlin关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-17T10:42:18+08:00">
                2018-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/12/Android-开发规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/Android-开发规范/" itemprop="url">Android 开发规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T10:05:46+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转自 : <a href="https://www.jianshu.com/p/45c1675bec69" target="_blank" rel="noopener">https://www.jianshu.com/p/45c1675bec69</a><br>作者 : Blankj</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Blankj/AndroidStandardDevelop/master/art/logo.png" alt=""></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>1 前言</li>
<li>2 AS 规范</li>
<li>3 命名规范</li>
<li>4 代码样式规范</li>
<li>5 资源文件规范</li>
<li>6 版本统一规范</li>
<li>7 第三方库规范</li>
<li>8 注释规范</li>
<li>9 测试规范</li>
<li>10 其他的一些规范</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>为了有利于项目维护、增强代码可读性、提升 Code Review 效率以及规范团队安卓开发，故提出以下安卓开发规范，该规范结合本人多年的开发经验并吸取多家之精华，可谓是本人的呕心沥血之作，称其为当前最完善的安卓开发规范一点也不为过，如有更好建议，欢迎到 GitHub 提 issue，原文地址：<a href="https://github.com/Blankj/AndroidStandardDevelop" target="_blank" rel="noopener"><strong><font color="#69f">Android 开发规范（完结版）</font></strong></a>。相关 Demo，可以查看我的 Android 开发工具类集合项目：<a href="https://github.com/Blankj/AndroidUtilCode" target="_blank" rel="noopener"><strong><font color="#69f">Android 开发人员不得不收集的代码</font></strong></a>。后续可能会根据该规范出一个 CheckStyle 插件来检查是否规范，当然也支持在 CI 上运行。</p>
<h2 id="2-AS-规范"><a href="#2-AS-规范" class="headerlink" title="2 AS 规范"></a>2 AS 规范</h2><p>工欲善其事，必先利其器。</p>
<ol>
<li>尽量使用最新的稳定版的 IDE 进行开发；</li>
<li>编码格式统一为 <strong>UTF-8</strong>；</li>
<li>编辑完 .java、.xml 等文件后一定要 <strong>格式化，格式化，格式化</strong>（如果团队有公共的样式包，那就遵循它，否则统一使用 AS 默认模板即可）；</li>
<li>删除多余的 import，减少警告出现，可利用 AS 的 Optimize Imports（Settings -&gt; Keymap -&gt; Optimize Imports）快捷键；</li>
<li>Android 开发者工具可以参考这里：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0526/7973.html" target="_blank" rel="noopener"><strong><font color="#69f">Android 开发者工具</font></strong></a>；</li>
</ol>
<h2 id="3-命名规范"><a href="#3-命名规范" class="headerlink" title="3 命名规范"></a>3 命名规范</h2><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。</p>
<blockquote>
<p>注意：即使纯拼音命名方式也要避免采用。但 alibaba、taobao、youku、hangzhou 等国际通用的名称，可视同英文。</p>
</blockquote>
<h3 id="3-1-包名"><a href="#3-1-包名" class="headerlink" title="3.1 包名"></a>3.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为 <code>com</code>、<code>edu</code>、<code>gov</code>、<code>net</code>、<code>org</code> 等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐采用 PBF（按功能分包 Package By Feature），一开始我们采用的也是 PBL（按层分包 Package By Layer），很坑爹。PBF 可能不是很好区分在哪个功能中，不过也比 PBL 要好找很多，且 PBF 与 PBL 相比较有如下优势：</p>
<ul>
<li><p>package 内高内聚，package 间低耦合</p>
<p>  哪块要添新功能，只改某一个 package 下的东西。</p>
<p>  PBL 降低了代码耦合，但带来了 package 耦合，要添新功能，需要改 model、dbHelper、view、service 等等，需要改动好几个 package 下的代码，改动的地方越多，越容易产生新问题，不是吗？</p>
<p>  PBF 的话 featureA 相关的所有东西都在 featureA 包，feature 内高内聚、高度模块化，不同 feature 之间低耦合，相关的东西都放在一起，还好找。</p>
</li>
<li><p>package 有私有作用域（package-private scope）</p>
<p>  你负责开发这块功能，这个目录下所有东西都是你的。</p>
<p>  PBL 的方式是把所有工具方法都放在 util 包下，小张开发新功能时候发现需要一个 xxUtil，但它又不是通用的，那应该放在哪里？没办法，按照分层原则，我们还得放在 util 包下，好像不太合适，但放在其它包更不合适，功能越来越多，util 类也越定义越多。后来小李负责开发一块功能时发现需要一个 xxUtil，同样不通用，去 util 包一看，怎么已经有了，而且还没法复用，只好放弃 xx 这个名字，改为 xxxUtil……，因为 PBL 的 package 没有私有作用域，每一个包都是 public（跨包方法调用是很平常的事情，每一个包对其它包来说都是可访问的）；如果是 PBF，小张的 xxUtil 自然放在 featureA 下，小李的 xxUtil 在 featureB 下，如果觉得 util 好像是通用的，就去 util 包看看要不要把工具方法添进 xxUtil, class 命名冲突没有了。</p>
<p>  PBF 的 package 有私有作用域，featureA 不应该访问 featureB 下的任何东西（如果非访问不可，那就说明接口定义有问题）。</p>
</li>
<li><p>很容易删除功能</p>
<p>  统计发现新功能没人用，这个版本那块功能得去掉。</p>
<p>  如果是 PBL，得从功能入口到整个业务流程把受到牵连的所有能删的代码和 class 都揪出来删掉，一不小心就完蛋。</p>
<p>  如果是 PBF，好说，先删掉对应包，再删掉功能入口（删掉包后入口肯定报错了），完事。</p>
</li>
<li><p>高度抽象</p>
<p>  解决问题的一般方法是从抽象到具体，PBF 包名是对功能模块的抽象，包内的 class 是实现细节，符合从抽象到具体，而 PBL 弄反了。</p>
<p>  PBF 从确定 AppName 开始，根据功能模块划分 package，再考虑每块的具体实现细节，而 PBL 从一开始就要考虑要不要 dao 层，要不要 com 层等等。</p>
</li>
<li><p>只通过 class 来分离逻辑代码</p>
<p>  PBL 既分离 class 又分离 package，而 PBF 只通过 class 来分离逻辑代码。</p>
<p>  没有必要通过 package 分离，因为 PBL 中也可能出现尴尬的情况：</p>
<pre><code>├── service
    ├── MainService.java
</code></pre><p>  按照 PBL, service 包下的所有东西都是 Service，应该不需要 Service 后缀，但实际上通常为了方便，直接 import service 包，Service 后缀是为了避免引入的 class 和当前包下的 class 命名冲突，当然，不用后缀也可以，得写清楚包路径，比如 <code>new com.domain.service.MainService()</code>，麻烦；而 PBF 就很方便，无需 import，直接 <code>new MainService()</code> 即可。</p>
</li>
<li><p>package 的大小有意义了</p>
<p>  PBL 中包的大小无限增长是合理的，因为功能越添越多，而 PBF 中包太大（包里 class 太多）表示这块需要重构（划分子包）。</p>
</li>
</ul>
<p>如要知道更多好处，可以查看这篇博文：<a href="httsps://hackernoon.com/package-by-features-not-layers-2d076df1964d" target="_blank" rel="noopener"><strong><font color="#69f">Package by features, not layers</font></strong></a>，当然，我们大谷歌也有相应的 Sample：<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="noopener"><strong><font color="#69f">todo-mvp</font></strong></a>，其结构如下所示，很值得学习。</p>
<pre><code>com
└── example
    └── android
        └── architecture
            └── blueprints
                └── todoapp
                    ├── BasePresenter.java
                    ├── BaseView.java
                    ├── addedittask
                    │   ├── AddEditTaskActivity.java
                    │   ├── AddEditTaskContract.java
                    │   ├── AddEditTaskFragment.java
                    │   └── AddEditTaskPresenter.java
                    ├── data
                    │   ├── Task.java
                    │   └── source
                    │       ├── TasksDataSource.java
                    │       ├── TasksRepository.java
                    │       ├── local
                    │       │   ├── TasksDbHelper.java
                    │       │   ├── TasksLocalDataSource.java
                    │       │   └── TasksPersistenceContract.java
                    │       └── remote
                    │           └── TasksRemoteDataSource.java
                    ├── statistics
                    │   ├── StatisticsActivity.java
                    │   ├── StatisticsContract.java
                    │   ├── StatisticsFragment.java
                    │   └── StatisticsPresenter.java
                    ├── taskdetail
                    │   ├── TaskDetailActivity.java
                    │   ├── TaskDetailContract.java
                    │   ├── TaskDetailFragment.java
                    │   └── TaskDetailPresenter.java
                    ├── tasks
                    │   ├── ScrollChildSwipeRefreshLayout.java
                    │   ├── TasksActivity.java
                    │   ├── TasksContract.java
                    │   ├── TasksFilterType.java
                    │   ├── TasksFragment.java
                    │   └── TasksPresenter.java
                    └── util
                        ├── ActivityUtils.java
                        ├── EspressoIdlingResource.java
                        └── SimpleCountingIdlingResource.java
</code></pre><p>参考以上的代码结构，按功能分包具体可以这样做：</p>
<pre><code>com
└── domain
    └── app
        ├── App.java 定义 Application 类
        ├── Config.java 定义配置数据（常量）
        ├── base 基础组件
        ├── custom_view 自定义视图
        ├── data 数据处理
        │   ├── DataManager.java 数据管理器，
        │   ├── local 来源于本地的数据，比如 SP，Database，File
        │   ├── model 定义 model（数据结构以及 getter/setter、compareTo、equals 等等，不含复杂操作）
        │   └── remote 来源于远端的数据
        ├── feature 功能
        │   ├── feature0 功能 0
        │   │   ├── feature0Activity.java
        │   │   ├── feature0Fragment.java
        │   │   ├── xxAdapter.java
        │   │   └── ... 其他 class
        │   └── ...其他功能
        ├── injection 依赖注入
        ├── util 工具类
        └── widget 小部件
</code></pre><h3 id="3-2-类名"><a href="#3-2-类名" class="headerlink" title="3.2 类名"></a>3.2 类名</h3><p>类名都以 <code>UpperCamelCase</code> 风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型</p>
<p>名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如 HTML、URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
<th>例如</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Activity</code> 类</td>
<td><code>Activity</code> 为后缀标识</td>
<td>欢迎页面类 <code>WelcomeActivity</code></td>
</tr>
<tr>
<td><code>Adapter</code> 类</td>
<td><code>Adapter</code> 为后缀标识</td>
<td>新闻详情适配器 <code>NewsDetailAdapter</code></td>
</tr>
<tr>
<td>解析类</td>
<td><code>Parser</code> 为后缀标识</td>
<td>首页解析类 <code>HomePosterParser</code></td>
</tr>
<tr>
<td>工具方法类</td>
<td><code>Utils</code> 或 <code>Manager</code> 为后缀标识</td>
<td>线程池管理类：<code>ThreadPoolManager</code><br>日志工具类：<code>LogUtils</code>（<code>Logger</code> 也可）<br>打印工具类：<code>PrinterUtils</code></td>
</tr>
<tr>
<td>数据库类</td>
<td>以 <code>DBHelper</code> 后缀标识</td>
<td>新闻数据库：<code>NewsDBHelper</code></td>
</tr>
<tr>
<td><code>Service</code> 类</td>
<td>以 <code>Service</code> 为后缀标识</td>
<td>时间服务 <code>TimeService</code></td>
</tr>
<tr>
<td><code>BroadcastReceiver</code> 类</td>
<td>以 k 为后缀标识</td>
<td>推送接收 <code>JPushReceiver</code></td>
</tr>
<tr>
<td><code>ContentProvider</code> 类</td>
<td>以 <code>Provider</code> 为后缀标识</td>
<td><code>ShareProvider</code></td>
</tr>
<tr>
<td>自定义的共享基础类</td>
<td>以 <code>Base</code> 开头</td>
<td><code>BaseActivity</code>, <code>BaseFragment</code></td>
</tr>
</tbody>
</table>
<p>测试类的命名以它要测试的类的名称开始，以 Test 结束。例如：<code>HashTest</code> 或 <code>HashIntegrationTest</code>。</p>
<p>接口（interface）：命名规则与类一样采用大驼峰命名法，多以 able 或 ible 结尾，如 <code>interface Runnable</code>、<code>interface Accessible</code>。</p>
<blockquote>
<p>注意：如果项目采用 MVP，所有 Model、View、Presenter 的接口都以 I 为前缀，不加后缀，其他的接口采用上述命名规则。</p>
</blockquote>
<h3 id="3-3-方法名"><a href="#3-3-方法名" class="headerlink" title="3.3 方法名"></a>3.3 方法名</h3><p>方法名都以 <code>lowerCamelCase</code> 风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>initXX()</code></td>
<td>初始化相关方法，使用 <code>init</code> 为前缀标识，如初始化布局 <code>initView()</code></td>
</tr>
<tr>
<td><code>isXX()</code><br><code>checkXX()</code></td>
<td>方法返回值为 <code>boolean</code> 型的请使用 <code>is/check</code> 为前缀标识</td>
</tr>
<tr>
<td><code>getXX()</code></td>
<td>返回某个值的方法，使用 <code>get</code> 为前缀标识</td>
</tr>
<tr>
<td><code>setXX()</code></td>
<td>设置某个属性值</td>
</tr>
<tr>
<td><code>handleXX()</code><br><code>processXX()</code></td>
<td>对数据进行处理的方法</td>
</tr>
<tr>
<td><code>displayXX()</code><br><code>showXX()</code></td>
<td>弹出提示框和提示信息，使用 <code>display/show</code> 为前缀标识</td>
</tr>
<tr>
<td><code>updateXX()</code></td>
<td>更新数据</td>
</tr>
<tr>
<td><code>saveXX()</code><br><code>insertXX()</code></td>
<td>保存或插入数据</td>
</tr>
<tr>
<td><code>resetXX()</code></td>
<td>重置数据</td>
</tr>
<tr>
<td><code>clearXX()</code></td>
<td>清除数据</td>
</tr>
<tr>
<td><code>removeXX()</code><br><code>deleteXX()</code></td>
<td>移除数据或者视图等，如 <code>removeView()</code></td>
</tr>
<tr>
<td><code>drawXX()</code></td>
<td>绘制数据或效果相关的，使用 <code>draw</code> 前缀标识</td>
</tr>
</tbody>
</table>
<h3 id="3-4-常量名"><a href="#3-4-常量名" class="headerlink" title="3.4 常量名"></a>3.4 常量名</h3><p>常量名命名模式为 <code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？</p>
<p>每个常量都是一个 <code>static final</code> 字段，但不是所有 <code>static final</code> 字段都是常量。在决定一个字段是否是一个常量时，得考虑它是否真的感觉像是一个常量。例如，如果观测任何一个该实例的状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变的对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Constants</span><br><span class="line">static final int NUMBER = 5;</span><br><span class="line">static final ImmutableListNAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</span><br><span class="line">static final Joiner COMMA_JOINER = Joiner.on(&apos;,&apos;); // because Joiner is immutable</span><br><span class="line">static final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line">// Not constants</span><br><span class="line">static String nonFinal = &quot;non-final&quot;;</span><br><span class="line">final String nonStatic = &quot;non-static&quot;;</span><br><span class="line">static final SetmutableCollection = new HashSet();</span><br><span class="line">static final ImmutableSetmutableElements = ImmutableSet.of(mutable);</span><br><span class="line">static final Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line">static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-非常量字段名"><a href="#3-5-非常量字段名" class="headerlink" title="3.5 非常量字段名"></a>3.5 非常量字段名</h3><p>非常量字段名以 <code>lowerCamelCase</code> 风格的基础上改造为如下风格：基本结构为 <code>scope{Type0}VariableName{Type1}</code>、<code>type0VariableName{Type1}</code>、<code>variableName{Type1}</code>。</p>
<p>说明：<code>{}</code> 中的内容为可选。</p>
<blockquote>
<p>注意：所有的 VO（值对象）统一采用标准的 lowerCamelCase 风格编写，所有的 DTO（数据传输对象）就按照接口文档中定义的字段名编写。</p>
</blockquote>
<h4 id="3-5-1-scope（范围）"><a href="#3-5-1-scope（范围）" class="headerlink" title="3.5.1 scope（范围）"></a>3.5.1 scope（范围）</h4><p>非公有，非静态字段命名以 m 开头。</p>
<p>静态字段命名以 s 开头。</p>
<p>其他字段以小写字母开头。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public int publicField;</span><br><span class="line">    private static MyClass sSingleton;</span><br><span class="line">    int mPackagePrivate;</span><br><span class="line">    private int mPrivate;</span><br><span class="line">    protected int mProtected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 1 个字符前缀来表示作用范围，1 个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。</p>
<h4 id="3-5-2-Type0（控件类型）"><a href="#3-5-2-Type0（控件类型）" class="headerlink" title="3.5.2 Type0（控件类型）"></a>3.5.2 Type0（控件类型）</h4><p>考虑到 Android 众多的 UI 控件，为避免控件和普通成员变量混淆以及更好地表达意思，所有用来表示控件的成员变量统一加上控件缩写作为前缀（具体见附录UI 控件缩写表）。</p>
<p>例如：<code>mIvAvatar</code>、<code>rvBooks</code>、<code>flContainer</code>。</p>
<h4 id="3-5-3-VariableName（变量名）"><a href="#3-5-3-VariableName（变量名）" class="headerlink" title="3.5.3 VariableName（变量名）"></a>3.5.3 VariableName（变量名）</h4><p>变量名中可能会出现量词，我们需要创建统一的量词，它们更容易理解，也更容易搜索。</p>
<p>例如：<code>mFirstBook</code>、<code>mPreBook</code>、<code>curBook</code>。</p>
<table>
<thead>
<tr>
<th>量词列表</th>
<th>量词后缀说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>First</td>
<td>一组变量中的第一个</td>
</tr>
<tr>
<td>Last</td>
<td>一组变量中的最后一个</td>
</tr>
<tr>
<td>Next</td>
<td>一组变量中的下一个</td>
</tr>
<tr>
<td>Pre</td>
<td>一组变量中的上一个</td>
</tr>
<tr>
<td>Cur</td>
<td>一组变量中的当前变量</td>
</tr>
</tbody>
</table>
<h4 id="3-5-4-Type1（数据类型）"><a href="#3-5-4-Type1（数据类型）" class="headerlink" title="3.5.4 Type1（数据类型）"></a>3.5.4 Type1（数据类型）</h4><p>对于表示集合或者数组的非常量字段名，我们可以添加后缀来增强字段的可读性，比如：</p>
<p>集合添加如下后缀：<code>List</code>、<code>Map</code>、<code>Set</code>。</p>
<p>数组添加如下后缀：<code>Arr</code>。</p>
<p>例如：<code>mIvAvatarList</code>、<code>userArr</code>、<code>firstNameSet</code>。</p>
<blockquote>
<p>注意：如果数据类型不确定的话，比如表示的是很多书，那么使用其复数形式来表示也可，例如 mBooks。</p>
</blockquote>
<h3 id="3-6-参数名"><a href="#3-6-参数名" class="headerlink" title="3.6 参数名"></a>3.6 参数名</h3><p>参数名以 <code>lowerCamelCase</code> 风格编写，参数应该避免用单个字符命名。</p>
<h3 id="3-7-局部变量名"><a href="#3-7-局部变量名" class="headerlink" title="3.7 局部变量名"></a>3.7 局部变量名</h3><p>局部变量名以 <code>lowerCamelCase</code> 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是 <code>final</code> 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="3-8-临时变量"><a href="#3-8-临时变量" class="headerlink" title="3.8 临时变量"></a>3.8 临时变量</h3><p>临时变量通常被取名为 <code>i</code>、<code>j</code>、<code>k</code>、<code>m</code> 和 <code>n</code>，它们一般用于整型；<code>c</code>、<code>d</code>、<code>e</code>，它们一般用于字符型。 如：<code>for (int i = 0; i &lt; len; i++)</code>。</p>
<h3 id="3-9-类型变量名"><a href="#3-9-类型变量名" class="headerlink" title="3.9 类型变量名"></a>3.9 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ol>
<li>单个的大写字母，后面可以跟一个数字（如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>）。</li>
<li>以类命名方式（<a href="https://www.jianshu.com/p/45c1675bec69#32-%E7%B1%BB%E5%90%8D" target="_blank" rel="noopener"><strong><font color="#69f">参考3.2 类名</font></strong></a>），后面加个大写的 T（如：<code>RequestT</code>, <code>FooBarT</code>）。<br>更多还可参考：<a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BA%AA%E5%BF%B5%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener"><strong><font color="#69f">阿里巴巴 Java 开发手册</font></strong></a></li>
</ol>
<h2 id="4-代码样式规范"><a href="#4-代码样式规范" class="headerlink" title="4 代码样式规范"></a>4 代码样式规范</h2><h3 id="4-1-使用标准大括号样式"><a href="#4-1-使用标准大括号样式" class="headerlink" title="4.1 使用标准大括号样式"></a>4.1 使用标准大括号样式</h3><p>左大括号不单独占一行，与其前面的代码位于同一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    int func() &#123;</span><br><span class="line">        if (something) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125; else if (somethingElse) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在条件语句周围添加大括号。例外情况：如果整个条件语句（条件和主体）适合放在同一行，那么您可以（但不是必须）将其全部放在一行上。例如，我们接受以下样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也接受以下样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (condition) body();</span><br></pre></td></tr></table></figure>
<p>但不接受以下样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">    body();  // bad!</span><br></pre></td></tr></table></figure>
<h3 id="4-2-编写简短方法"><a href="#4-2-编写简短方法" class="headerlink" title="4.2 编写简短方法"></a>4.2 编写简短方法</h3><p>在可行的情况下，尽量编写短小精炼的方法。我们了解，有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。</p>
<h3 id="4-3-类成员的顺序"><a href="#4-3-类成员的顺序" class="headerlink" title="4.3 类成员的顺序"></a>4.3 类成员的顺序</h3><p>这并没有唯一的正确解决方案，但如果都使用一致的顺序将会提高代码的可读性，推荐使用如下排序：</p>
<ol>
<li>常量</li>
<li>字段</li>
<li>构造函数</li>
<li>重写函数和回调</li>
<li>公有函数</li>
<li>私有函数</li>
<li>内部类或接口</li>
</ol>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = MainActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    private String mTitle;</span><br><span class="line">    private TextView mTextViewTitle;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        mTitle = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setUpView() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class AnInnerClass &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类继承于 <code>Android</code> 组件（例如 <code>Activity</code> 或 <code>Fragment</code>），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，<code>Activity</code> 实现了 <code>onCreate()</code>、<code>onDestroy()</code>、<code>onPause()</code>、<code>onResume()</code>，它的正确排序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    //Order matches Activity lifecycle</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResume() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onPause() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-函数参数的排序"><a href="#4-4-函数参数的排序" class="headerlink" title="4.4 函数参数的排序"></a>4.4 函数参数的排序</h3><p>在 Android 开发过程中，<code>Context</code> 在函数参数中是再常见不过的了，我们最好把 <code>Context</code> 作为其第一个参数。</p>
<p>正相反，我们把回调接口应该作为其最后一个参数。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Context always goes first</span><br><span class="line">public User loadUser(Context context, int userId);</span><br><span class="line"></span><br><span class="line">// Callbacks always go last</span><br><span class="line">public void loadUserAsync(Context context, int userId, UserCallback callback);</span><br></pre></td></tr></table></figure>
<h3 id="4-5-字符串常量的命名和值"><a href="#4-5-字符串常量的命名和值" class="headerlink" title="4.5 字符串常量的命名和值"></a>4.5 字符串常量的命名和值</h3><p>Android SDK 中的很多类都用到了键值对函数，比如<code>SharedPreferences</code>、<code>Bundle</code>、<code>Intent</code>，所以，即便是一个小应用，我们最终也不得不编写大量的字符串常量。</p>
<p>当时用到这些类的时候，我们 必须 将它们的键定义为 <code>static final</code> 字段，并遵循以下指示作为前缀。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>字段名前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>SharedPreferences</td>
<td>PREF_</td>
</tr>
<tr>
<td>Bundle</td>
<td>BUNDLE_</td>
</tr>
<tr>
<td>Fragment Arguments</td>
<td>ARGUMENT_</td>
</tr>
<tr>
<td>Intent Extra</td>
<td>EXTRA_</td>
</tr>
<tr>
<td>Intent Action</td>
<td>ACTION_</td>
</tr>
</tbody>
</table>
<p>说明：虽然 Fragment.getArguments() 得到的也是 Bundle ，但因为这是 Bundle 的常用用法，所以特意为此定义一个不同的前缀。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注意：字段的值与名称相同以避免重复问题</span><br><span class="line">static final String PREF_EMAIL = &quot;PREF_EMAIL&quot;;</span><br><span class="line">static final String BUNDLE_AGE = &quot;BUNDLE_AGE&quot;;</span><br><span class="line">static final String ARGUMENT_USER_ID = &quot;ARGUMENT_USER_ID&quot;;</span><br><span class="line"></span><br><span class="line">// 与意图相关的项使用完整的包名作为值的前缀</span><br><span class="line">static final String EXTRA_SURNAME = &quot;com.myapp.extras.EXTRA_SURNAME&quot;;</span><br><span class="line">static final String ACTION_OPEN_USER = &quot;com.myapp.action.ACTION_OPEN_USER&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-Activities-和-Fragments-的传参"><a href="#4-6-Activities-和-Fragments-的传参" class="headerlink" title="4.6 Activities 和 Fragments 的传参"></a>4.6 Activities 和 Fragments 的传参</h3><p>当 <code>Activity</code> 或 <code>Fragment</code> 传递数据通过 <code>Intent</code> 或 <code>Bundle</code> 时，不同值的键须遵循上一条所提及到的。</p>
<p>当 <code>Activity</code> 或 <code>Fragment</code> 启动需要传递参数时，那么它需要提供一个 <code>public static</code> 的函数来帮助启动或创建它。</p>
<p>这方面，AS 已帮你写好了相关的 Live Templates，启动相关 <code>Activity</code> 的只需要在其内部输入 <code>starter</code> 即可生成它的启动器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void start(Context context, User user) &#123;</span><br><span class="line">      Intent starter = new Intent(context, MainActivity.class);</span><br><span class="line">      starter.putParcelableExtra(EXTRA_USER, user);</span><br><span class="line">      context.startActivity(starter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，启动相关 <code>Fragment</code> 在其内部输入 <code>newInstance</code> 即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static MainFragment newInstance(User user) &#123;</span><br><span class="line">      Bundle args = new Bundle();</span><br><span class="line">      args.putParcelable(ARGUMENT_USER, user);</span><br><span class="line">      MainFragment fragment = new MainFragment();</span><br><span class="line">      fragment.setArguments(args);</span><br><span class="line">      return fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这些函数需要放在 onCreate() 之前的类的顶部；如果我们使用了这种方式，那么 extras 和 arguments 的键应该是 private 的，因为它们不再需要暴露给其他类来使用。</p>
</blockquote>
<h3 id="4-7-行长限制"><a href="#4-7-行长限制" class="headerlink" title="4.7 行长限制"></a>4.7 行长限制</h3><p>代码中每一行文本的长度都应该不超过 100 个字符。虽然关于此规则存在很多争论，但最终决定仍是以 100 个字符为上限，如果行长超过了 100（AS 窗口右侧的竖线就是设置的行宽末尾 ），我们通常有两种方法来缩减行长。</p>
<ul>
<li>提取一个局部变量或方法（最好）。</li>
<li>使用换行符将一行换成多行。</li>
</ul>
<p>不过存在以下例外情况：</p>
<ul>
<li>如果备注行包含长度超过 100 个字符的示例命令或文字网址，那么为了便于剪切和粘贴，该行可以超过 100 个字符。</li>
<li>导入语句行可以超出此限制，因为用户很少会看到它们（这也简化了工具编写流程）。</li>
</ul>
<h4 id="4-7-1-换行策略"><a href="#4-7-1-换行策略" class="headerlink" title="4.7.1 换行策略"></a>4.7.1 换行策略</h4><p>这没有一个准确的解决方案来决定如何换行，通常不同的解决方案都是有效的，但是有一些规则可以应用于常见的情况。</p>
<h5 id="4-7-1-1-操作符的换行"><a href="#4-7-1-1-操作符的换行" class="headerlink" title="4.7.1.1 操作符的换行"></a>4.7.1.1 操作符的换行</h5><p>除赋值操作符之外，我们把换行符放在操作符之前，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne</span><br><span class="line">        + theFinalOne;</span><br></pre></td></tr></table></figure>
<p>赋值操作符的换行我们放在其后，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int longName =</span><br><span class="line">        anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne;</span><br></pre></td></tr></table></figure>
<h5 id="4-7-1-2-函数链的换行"><a href="#4-7-1-2-函数链的换行" class="headerlink" title="4.7.1.2 函数链的换行"></a>4.7.1.2 函数链的换行</h5><p>当同一行中调用多个函数时（比如使用构建器时），对每个函数的调用应该在新的一行中，我们把换行符插入在 <code>.</code> 之前。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context).load(&quot;https://blankj.com/images/avatar.jpg&quot;).into(ivAvatar);</span><br></pre></td></tr></table></figure>
<p>我们应该使用如下规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context)</span><br><span class="line">        .load(&quot;https://blankj.com/images/avatar.jpg&quot;)</span><br><span class="line">        .into(ivAvatar);</span><br></pre></td></tr></table></figure>
<h5 id="4-7-1-3-多参数的换行"><a href="#4-7-1-3-多参数的换行" class="headerlink" title="4.7.1.3 多参数的换行"></a>4.7.1.3 多参数的换行</h5><p>当一个方法有很多参数或者参数很长的时候，我们应该在每个 , 后面进行换行。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(context, &quot;https://blankj.com/images/avatar.jpg&quot;, ivAvatar, &quot;Avatar of the user&quot;, clickListener);</span><br></pre></td></tr></table></figure>
<p>我们应该使用如下规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(context,</span><br><span class="line">        &quot;https://blankj.com/images/avatar.jpg&quot;,</span><br><span class="line">        ivAvatar,</span><br><span class="line">        &quot;Avatar of the user&quot;,</span><br><span class="line">        clickListener);</span><br></pre></td></tr></table></figure>
<h6 id="4-7-1-4-RxJava-链式的换行"><a href="#4-7-1-4-RxJava-链式的换行" class="headerlink" title="4.7.1.4 RxJava 链式的换行"></a>4.7.1.4 RxJava 链式的换行</h6><p>RxJava 的每个操作符都需要换新行，并且把换行符插入在 . 之前。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Observable&lt;Location&gt; syncLocations() &#123;</span><br><span class="line">    return mDatabaseHelper.getAllLocations()</span><br><span class="line">            .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                 public Observable&lt;? extends Location&gt; call(Location location) &#123;</span><br><span class="line">                     return mRetrofitService.getLocation(location.id);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public Boolean call(Integer numRetries, Throwable throwable) &#123;</span><br><span class="line">                     return throwable instanceof RetrofitError;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-资源文件规范"><a href="#5-资源文件规范" class="headerlink" title="5 资源文件规范"></a>5 资源文件规范</h2><p>资源文件命名为全部小写，采用下划线命名法。</p>
<p>如果想对资源文件进行分包可以参考我这篇文章：<a href="https://blankj.com/2016/09/21/android-studio-classify-src-package/" target="_blank" rel="noopener"><strong><font color="#69f">Android Studio 下对资源进行分包</font></strong></a>。</p>
<p><img src="https://blankj.com/2016/09/21/android-studio-classify-src-package/classify_dir.png" alt=""></p>
<p>从图中可以看出新增了 <code>res_core</code> 和 <code>res_sub</code> 两个资源包，这样我们可以对每个模块的资源都进行具体分类，是不是心动了，赶紧照着如下配置试一试吧，别再让资源文件们“混为一潭”了。</p>
<p>方法很简单，配置我们的app文件夹下的 <code>build.gradle</code> 文件，比如</p>
<pre><code>android {
    ...
    sourceSets {
        main {
            res.srcDirs(&apos;src/main/res&apos;, &apos;src/main/res_core&apos;, &apos;src/main/res_sub&apos;)
        }
    }
}
</code></pre><p>配置完之后，sync project 一下就成功了。</p>
<h3 id="5-1-动画资源文件（anim-和-animator-）"><a href="#5-1-动画资源文件（anim-和-animator-）" class="headerlink" title="5.1 动画资源文件（anim/ 和 animator/）"></a>5.1 动画资源文件（anim/ 和 animator/）</h3><p>安卓主要包含属性动画和视图动画，其视图动画包括补间动画和逐帧动画。属性动画文件需要放在 <code>res/animator/</code> 目录下，视图动画文件需放在 <code>res/anim/</code> 目录下。</p>
<p>命名规则：<code>{模块名_}逻辑名称</code>。</p>
<p>说明：<code>{}</code> 中的内容为可选，逻辑名称 可由多个单词加下划线组成。</p>
<p>例如：<code>refresh_progress.xml</code>、<code>market_cart_add.xml</code>、<code>market_cart_remove.xml</code>。</p>
<p>如果是普通的补间动画或者属性动画，可采用：<code>动画类型_方向</code> 的命名方式。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fade_in</code></td>
<td>淡入</td>
</tr>
<tr>
<td><code>fade_out</code></td>
<td>淡出</td>
</tr>
<tr>
<td><code>push_down_in</code></td>
<td>从下方推入</td>
</tr>
<tr>
<td><code>push_down_out</code></td>
<td>从下方推出</td>
</tr>
<tr>
<td><code>push_left</code></td>
<td>推向左方</td>
</tr>
<tr>
<td><code>slide_in_from_top</code></td>
<td>从头部滑动进入</td>
</tr>
<tr>
<td><code>zoom_enter</code></td>
<td>变形进入</td>
</tr>
<tr>
<td><code>slide_in</code></td>
<td>滑动进入</td>
</tr>
<tr>
<td><code>shrink_to_middle</code></td>
<td>中间缩小</td>
</tr>
</tbody>
</table>
<h3 id="5-2-颜色资源文件（color-）"><a href="#5-2-颜色资源文件（color-）" class="headerlink" title="5.2 颜色资源文件（color/）"></a>5.2 颜色资源文件（color/）</h3><p>专门存放颜色相关的资源文件。</p>
<p>命名规则：<code>类型_逻辑名称</code>。</p>
<p>例如：<code>sel_btn_font.xml</code>。</p>
<p>颜色资源也可以放于 <code>res/drawable/</code> 目录，引用时则用 <code>@drawable</code> 来引用，但不推荐这么做，最好还是把两者分开。</p>
<h3 id="5-3-图片资源文件（drawable-和-mipmap-）"><a href="#5-3-图片资源文件（drawable-和-mipmap-）" class="headerlink" title="5.3 图片资源文件（drawable/ 和 mipmap/）"></a>5.3 图片资源文件（drawable/ 和 mipmap/）</h3><p><code>res/drawable/</code> 目录下放的是位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为可绘制对象资源子类型的 XML 文件，而 <code>res/mipmap/</code> 目录下放的是不同密度的启动图标，所以 <code>res/mipmap/</code> 只用于存放启动图标，其余图片资源文件都应该放到 <code>res/drawable/</code> 目录下。</p>
<p>命名规则：<code>类型{_模块名}_逻辑名称</code>、<code>类型{_模块名}_颜色</code>。</p>
<p>说明：<code>{}</code> 中的内容为可选；<code>类型</code> 可以是<a href=""><strong><font color="#69f">可绘制对象资源类型</font></strong></a>，也可以是控件类型（具体见附录<a href="">UI 控件缩写表</a>）；最后可加后缀 <code>_small</code> 表示小图，<code>_big</code> 表示大图。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>btn_main_about.png</code></td>
<td>主页关于按键 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>btn_back.png</code></td>
<td>返回按键 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>divider_maket_white.png</code></td>
<td>商城白色分割线 <code>类型_模块名_颜色</code></td>
</tr>
<tr>
<td><code>ic_edit.png</code></td>
<td>编辑图标 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>bg_main.png</code></td>
<td>主页背景 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>btn_red.png</code></td>
<td>红色按键 <code>类型_颜色</code></td>
</tr>
<tr>
<td><code>btn_red_big.png</code></td>
<td>红色大按键 <code>类型_颜色</code></td>
</tr>
<tr>
<td><code>ic_head_small.png</code></td>
<td>小头像图标 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>bg_input.png</code></td>
<td>输入框背景 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>divider_white.png</code></td>
<td>白色分割线 <code>类型_颜色</code></td>
</tr>
<tr>
<td><code>bg_main_head.png</code></td>
<td>主页头部背景 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>def_search_cell.png</code></td>
<td>搜索页面默认单元图片 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>ic_more_help.png</code></td>
<td>更多帮助图标 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>divider_list_line.png</code></td>
<td>列表分割线 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>sel_search_ok.xml</code></td>
<td>搜索界面确认选择器 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>shape_music_ring.xml</code></td>
<td>音乐界面环形形状 <code>类型_模块名_逻辑名称</code></td>
</tr>
</tbody>
</table>
<p>如果有多种形态，如按钮选择器：<code>sel_btn_xx.xml</code>，采用如下命名：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sel_btn_xx</code></td>
<td>作用在 <code>btn_xx</code> 上的 <code>selector</code></td>
</tr>
<tr>
<td><code>btn_xx_normal</code></td>
<td>默认状态效果</td>
</tr>
<tr>
<td><code>btn_xx_pressed</code></td>
<td><code>state_pressed</code> 点击效果</td>
</tr>
<tr>
<td><code>btn_xx_focused</code></td>
<td><code>state_focused</code> 聚焦效果</td>
</tr>
<tr>
<td><code>btn_xx_disabled</code></td>
<td><code>state_enabled</code> 不可用效果</td>
</tr>
<tr>
<td><code>btn_xx_checked</code></td>
<td><code>state_checked</code> 选中效果</td>
</tr>
<tr>
<td><code>btn_xx_selected</code></td>
<td><code>state_selected</code> 选中效果</td>
</tr>
<tr>
<td><code>btn_xx_hovered</code></td>
<td><code>state_hovered</code> 悬停效果</td>
</tr>
<tr>
<td><code>btn_xx_checkable</code></td>
<td><code>state_checkable</code> 可选效果</td>
</tr>
<tr>
<td><code>btn_xx_activated</code></td>
<td><code>state_activated</code> 激活效果</td>
</tr>
<tr>
<td><code>btn_xx_window_focused</code></td>
<td><code>state_window_focused</code> 窗口聚焦效果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：使用 Android Studio 的插件 SelectorChapek 可以快速生成 selector，前提是命名要规范。</p>
</blockquote>
<h3 id="5-4-布局资源文件（layout-）"><a href="#5-4-布局资源文件（layout-）" class="headerlink" title="5.4 布局资源文件（layout/）"></a>5.4 布局资源文件（layout/）</h3><p>命名规则：<code>类型_模块名</code>、<code>类型{_模块名}_逻辑名称</code>。</p>
<p>说明：<code>{}</code> 中的内容为可选。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>activity_main.xml</code></td>
<td>主窗体 <code>类型_模块名</code></td>
</tr>
<tr>
<td><code>activity_main_head.xml</code></td>
<td>主窗体头部 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>fragment_music.xml</code></td>
<td>音乐片段 <code>类型_模块名</code></td>
</tr>
<tr>
<td><code>fragment_music_player.xml</code></td>
<td>音乐片段的播放器 <code>类型_模块名_逻辑名称</code></td>
</tr>
<tr>
<td><code>dialog_loading.xml</code></td>
<td>加载对话框 <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>ppw_info.xml</code></td>
<td>信息弹窗（PopupWindow） <code>类型_逻辑名称</code></td>
</tr>
<tr>
<td><code>item_main_song.xml</code></td>
<td>主页歌曲列表项 <code>类型_模块名_逻辑名称</code></td>
</tr>
</tbody>
</table>
<h3 id="5-5-菜单资源文件（menu-）"><a href="#5-5-菜单资源文件（menu-）" class="headerlink" title="5.5 菜单资源文件（menu/）"></a>5.5 菜单资源文件（menu/）</h3><p>菜单相关的资源文件应放在该目录下。</p>
<p>命名规则：<code>{模块名_}逻辑名称</code></p>
<p>说明：<code>{}</code> 中的内容为可选。</p>
<p>例如：<code>main_drawer.xml</code>、<code>navigation.xml</code>。</p>
<h3 id="5-6-values-资源文件（values-）"><a href="#5-6-values-资源文件（values-）" class="headerlink" title="5.6 values 资源文件（values/）"></a>5.6 values 资源文件（values/）</h3><p><code>values/</code> 资源文件下的文件都以 <code>s</code> 结尾，如 <code>attrs.xml</code>、<code>colors.xml</code>、<code>dimens.xml</code>，起作用的不是文件名称，而是 <code>&lt;resources&gt;</code> 标签下的各种标签，比如 <code>&lt;style&gt;</code> 决定样式，<code>&lt;color&gt;</code> 决定颜色，所以，可以把一个大的 <code>xml</code> 文件分割成多个小的文件，比如可以有多个 <code>style</code> 文件，如 <code>styles.xml</code>、<code>styles_home.xml</code>、<code>styles_item_details.xml</code>、<code>styles_forms.xml</code>。</p>
<h4 id="5-6-1-colors-xml"><a href="#5-6-1-colors-xml" class="headerlink" title="5.6.1 colors.xml"></a>5.6.1 colors.xml</h4><p><code>&lt;color&gt;</code> 的 <code>name</code> 命名使用下划线命名法，在你的 <code>colors.xml</code> 文件中应该只是映射颜色的名称一个 ARGB 值，而没有其它的。不要使用它为不同的按钮来定义 ARGB 值。</p>
<p>例如，不要像下面这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  &lt;color name=&quot;button_foreground&quot;&gt;#FFFFFF&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;button_background&quot;&gt;#2A91BD&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;comment_background_inactive&quot;&gt;#5F5F5F&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;comment_background_active&quot;&gt;#939393&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;comment_foreground&quot;&gt;#FFFFFF&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;comment_foreground_important&quot;&gt;#FF9D2F&lt;/color&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;color name=&quot;comment_shadow&quot;&gt;#323232&lt;/color&gt;</span><br></pre></td></tr></table></figure>
<p>使用这种格式，会非常容易重复定义 ARGB 值，而且如果应用要改变基色的话会非常困难。同时，这些定义是跟一些环境关联起来的，如 <code>button</code> 或者 <code>comment</code>，应该放到一个按钮风格中，而不是在 <code>colors.xml</code> 文件中。</p>
<p>相反，应该这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- grayscale --&gt;</span><br><span class="line">  &lt;color name=&quot;white&quot;     &gt;#FFFFFF&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;gray_light&quot;&gt;#DBDBDB&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;gray&quot;      &gt;#939393&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;gray_dark&quot; &gt;#5F5F5F&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;black&quot;     &gt;#323232&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- basic colors --&gt;</span><br><span class="line">  &lt;color name=&quot;green&quot;&gt;#27D34D&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;blue&quot;&gt;#2A91BD&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;orange&quot;&gt;#FF9D2F&lt;/color&gt;</span><br><span class="line">  &lt;color name=&quot;red&quot;&gt;#FF432F&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>向应用设计者那里要这个调色板，名称不需要跟 <code>&quot;green&quot;</code>、<code>&quot;blue&quot;</code> 等等相同。<code>&quot;brand_primary&quot;</code>、<code>&quot;brand_secondary&quot;</code>、<code>&quot;brand_negative&quot;</code> 这样的名字也是完全可以接受的。像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。通常一个具有审美价值的 UI 来说，减少使用颜色的种类是非常重要的。</p>
<blockquote>
<p>注意：如果某些颜色和主题有关，那就单独写一个 colors_theme.xml。</p>
</blockquote>
<h4 id="5-6-2-dimens-xml"><a href="#5-6-2-dimens-xml" class="headerlink" title="5.6.2 dimens.xml"></a>5.6.2 dimens.xml</h4><p>像对待 <code>colors.xml</code> 一样对待 <code>dimens.xml</code> 文件，与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- font sizes --&gt;</span><br><span class="line">    &lt;dimen name=&quot;font_22&quot;&gt;22sp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;font_18&quot;&gt;18sp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;font_15&quot;&gt;15sp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;font_12&quot;&gt;12sp&lt;/dimen&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typical spacing between two views --&gt;</span><br><span class="line">    &lt;dimen name=&quot;spacing_40&quot;&gt;40dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;spacing_24&quot;&gt;24dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;spacing_14&quot;&gt;14dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;spacing_10&quot;&gt;10dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;spacing_4&quot;&gt;4dp&lt;/dimen&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typical sizes of views --&gt;</span><br><span class="line">    &lt;dimen name=&quot;button_height_60&quot;&gt;60dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;button_height_40&quot;&gt;40dp&lt;/dimen&gt;</span><br><span class="line">    &lt;dimen name=&quot;button_height_32&quot;&gt;32dp&lt;/dimen&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>布局时在写 <code>margins</code> 和 <code>paddings</code> 时，你应该使用 <code>spacing_xx</code> 尺寸格式来布局，而不是像对待 <code>string</code> 字符串一样直接写值，像这样规范的尺寸很容易修改或重构，会使应用所有用到的尺寸一目了然。 这样写会非常有感觉，会使组织和改变风格或布局非常容易。</p>
<h4 id="5-6-3-strings-xml"><a href="#5-6-3-strings-xml" class="headerlink" title="5.6.3 strings.xml"></a>5.6.3 strings.xml</h4><p><code>&lt;string&gt;</code> 的 <code>name</code> 命名使用下划线命名法，采用以下规则：<code>{模块名_}逻辑名称</code>，这样方便同一个界面的所有 <code>string</code> 都放到一起，方便查找。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>main_menu_about</td>
<td>主菜单按键文字</td>
</tr>
<tr>
<td>friend_title</td>
<td>好友模块标题栏</td>
</tr>
<tr>
<td>friend_dialog_del</td>
<td>好友删除提示</td>
</tr>
<tr>
<td>login_check_email</td>
<td>登录验证</td>
</tr>
<tr>
<td>dialog_title</td>
<td>弹出框标题</td>
</tr>
<tr>
<td>button_ok</td>
<td>确认键</td>
</tr>
<tr>
<td>loading</td>
<td>加载文字</td>
</tr>
</tbody>
</table>
<h4 id="5-6-4-styles-xml"><a href="#5-6-4-styles-xml" class="headerlink" title="5.6.4 styles.xml"></a>5.6.4 styles.xml</h4><p><code>&lt;style&gt;</code> 的 <code>name</code> 命名使用大驼峰命名法，几乎每个项目都需要适当的使用 <code>styles.xml</code> 文件，因为对于一个视图来说，有一个重复的外观是很常见的，将所有的外观细节属性（<code>colors</code>、<code>padding</code>、<code>font</code>）放在 <code>styles.xml</code> 文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的 <code>styles.xml</code> 文件，例如：</p>
<pre><code>&lt;style name=&quot;ContentText&quot;&gt;
    &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;@color/basic_black&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>应用到 TextView 中：</p>
<pre><code>&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;@string/price&quot;
    style=&quot;@style/ContentText&quot;
    /&gt;
</code></pre><p>或许你需要为按钮控件做同样的事情，不要停止在那里，将一组相关的和重复 <code>android:xxxx</code> 的属性放到一个通用的 <code>&lt;style&gt;</code> 中。</p>
<h3 id="5-7-id-命名"><a href="#5-7-id-命名" class="headerlink" title="5.7 id 命名"></a>5.7 id 命名</h3><p>命名规则：<code>view缩写{_模块名}_逻辑名</code>，例如： <code>btn_main_search</code>、<code>btn_back</code>。</p>
<p>如果在项目中有用黄油刀的话，使用 AS 的插件：ButterKnife Zelezny，可以非常方便帮助你生成注解；没用黄油刀的话可以使用 Android Code Generator 插件。</p>
<h2 id="6-版本统一规范"><a href="#6-版本统一规范" class="headerlink" title="6 版本统一规范"></a>6 版本统一规范</h2><p>Android 开发存在着众多版本的不同，比如 <code>compileSdkVersion</code>、<code>minSdkVersion</code>、<code>targetSdkVersion</code> 以及项目中依赖第三方库的版本，不同的 module 及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。</p>
<p>具体可以参考这篇博文：<a href="https://blankj.com/2016/09/21/android-keep-version-unity/" target="_blank" rel="noopener"><strong><font color="#69f">Android 开发之版本统一规范</font></strong></a>。</p>
<p>如果是开发多个系统级别的应用，当多个应用同时用到相同的 <code>so</code> 库时，一定要确保 <code>so</code> 库的版本一致，否则可能会引发应用崩溃。</p>
<h2 id="7-第三方库规范"><a href="#7-第三方库规范" class="headerlink" title="7 第三方库规范"></a>7 第三方库规范</h2><p>别再闭门造车了，用用最新最火的技术吧，安利一波：<a href=""><strong><font color="#69f">Android 流行框架查速表</font></strong></a>，顺便带上自己的干货：<a href="">Android 开发人员不得不收集的代码</a>。</p>
<p>希望 Team 能用时下较新的技术，对开源库的选取，一般都需要选择比较稳定的版本，作者在维护的项目，要考虑作者对 issue 的解决，以及开发者的知名度等各方面。选取之后，一定的封装是必要的。</p>
<p>个人推荐 Team 可使用如下优秀轮子：</p>
<ul>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="noopener"><strong><font color="#69f">Retrofit</font></strong></a></li>
<li><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener"><strong><font color="#69f">RxAndroid</font></strong></a></li>
<li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener"><strong><font color="#69f">OkHttp</font></strong></a></li>
<li><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener"><strong><font color="#69f">Glide</font></strong></a> / <a href="https://github.com/facebook/fresco" target="_blank" rel="noopener"><strong><font color="#69f">Fresco</font></strong></a></li>
<li><a href="https://github.com/google/gson" target="_blank" rel="noopener"><strong><font color="#69f">Gson</font></strong></a> / <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener"><strong><font color="#69f">Fastjson</font></strong></a></li>
<li><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener"><strong><font color="#69f">EventBus</font></strong></a> / <a href="https://github.com/bboyfeiyu/AndroidEventBus" target="_blank" rel="noopener"><strong><font color="#69f">AndroidEventBus</font></strong></a></li>
<li><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener"><strong><font color="#69f">GreenDao</font></strong></a></li>
<li><a href="https://github.com/google/dagger" target="_blank" rel="noopener"><strong><font color="#69f">Dagger2（选用）</font></strong></a></li>
<li><a href="https://github.com/Tencent/tinker" target="_blank" rel="noopener"><strong><font color="#69f">Tinker（选用）</font></strong></a></li>
</ul>
<h2 id="8-注释规范"><a href="#8-注释规范" class="headerlink" title="8 注释规范"></a>8 注释规范</h2><p>为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。</p>
<h3 id="8-1-类注释"><a href="#8-1-类注释" class="headerlink" title="8.1 类注释"></a>8.1 类注释</h3><p>每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。</p>
<pre><code>/**
 * &lt;pre&gt;
 *     author : Blankj
 *     e-mail : xxx@xx
 *     time   : 2017/03/07
 *     desc   : xxxx 描述
 *     version: 1.0
 * &lt;/pre&gt;
 */
public class WelcomeActivity {
    ...
}
</code></pre><p>具体可以在 AS 中自己配制，进入 Settings -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header，输入</p>
<pre><code>/**
 * &lt;pre&gt;
 *     author : ${USER}
 *     e-mail : xxx@xx
 *     time   : ${YEAR}/${MONTH}/${DAY}
 *     desc   :
 *     version: 1.0
 * &lt;/pre&gt;
 */
</code></pre><p>这样便可在每次新建类的时候自动加上该头注释。</p>
<h3 id="8-2-方法注释"><a href="#8-2-方法注释" class="headerlink" title="8.2 方法注释"></a>8.2 方法注释</h3><p>每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入 <code>/** + 回车</code> 或者设置 <code>Fix doc comment</code>（Settings -&gt; Keymap -&gt; Fix doc comment）快捷键，AS 便会帮你生成模板，我们只需要补全参数即可，如下所示。</p>
<pre><code>/**
 * bitmap 转 byteArr
 *
 * @param bitmap bitmap 对象
 * @param format 格式
 * @return 字节数组
 */
public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) {
    if (bitmap == null) return null;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    bitmap.compress(format, 100, baos);
    return baos.toByteArray();
}
</code></pre><h3 id="8-3-块注释"><a href="#8-3-块注释" class="headerlink" title="8.3 块注释"></a>8.3 块注释</h3><p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格（<code>//</code>后最好带一个空格）。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。以下示例注释都是 OK 的。</p>
<pre><code>/*
 * This is
 * okay.
 */

// And so
// is this.

/* Or you can
* even do this. */
</code></pre><p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行（即注释像段落风格一样），那么使用 /<em> … </em>/。</p>
</blockquote>
<h3 id="8-4-其他一些注释"><a href="#8-4-其他一些注释" class="headerlink" title="8.4 其他一些注释"></a>8.4 其他一些注释</h3><p>AS 已帮你集成了一些注释模板，我们只需要直接使用即可，在代码中输入 <code>todo</code>、<code>fixme</code> 等这些注释模板，回车后便会出现如下注释。</p>
<pre><code>// TODO: 17/3/14 需要实现，但目前还未实现的功能的说明
// FIXME: 17/3/14 需要修正，甚至代码是错误的，不能工作，需要修复的说明
</code></pre><h2 id="9-测试规范"><a href="#9-测试规范" class="headerlink" title="9 测试规范"></a>9 测试规范</h2><p>业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过，同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。</p>
<h3 id="9-1-单元测试"><a href="#9-1-单元测试" class="headerlink" title="9.1 单元测试"></a>9.1 单元测试</h3><p>测试类的名称应该是所测试类的名称加 <code>Test</code>，我们创建 <code>DatabaseHelper</code> 的测试类，其名应该叫 <code>DatabaseHelperTest</code>。</p>
<p>测试函数被 <code>@Test</code> 所注解，函数名通常以被测试的方法为前缀，然后跟随是前提条件和预期的结果。</p>
<p>模板：<code>void methodName 前提条件和预期结果()</code><br>例子：<code>void signInWithEmptyEmailFails()</code></p>
<blockquote>
<p>注意：如果函数足够清晰，那么前提条件和预期的结果是可以省略的。</p>
</blockquote>
<p>有时一个类可能包含大量的方法，同时需要对每个方法进行几次测试。在这种情况下，建议将测试类分成多个类。例如，如果 <code>DataManager</code> 包含很多方法，我们可能要把它分成 <code>DataManagerSignInTest</code>、<code>DataManagerLoadUsersTest</code> 等等。</p>
<h3 id="9-2-Espresso-测试"><a href="#9-2-Espresso-测试" class="headerlink" title="9.2 Espresso 测试"></a>9.2 Espresso 测试</h3><p>每个 Espresso 测试通常是针对 <code>Activity</code>，所以其测试名就是其被测的 <code>Activity</code> 的名称加 <code>Test</code>，比如 <code>SignInActivityTest</code>。</p>
<h2 id="10-其他的一些规范"><a href="#10-其他的一些规范" class="headerlink" title="10 其他的一些规范"></a>10 其他的一些规范</h2><ol>
<li><p>合理布局，有效运用 <code>&lt;merge&gt;</code>、<code>&lt;ViewStub&gt;</code>、<code>&lt;include&gt;</code> 标签；</p>
</li>
<li><p><code>Activity</code> 和 <code>Fragment</code> 里面有许多重复的操作以及操作步骤，所以我们都需要提供一个 <code>BaseActivity</code> 和 <code>BaseFragment</code>，让所有的 <code>Activity</code> 和 <code>Fragment</code> 都继承这个基类。</p>
</li>
<li><p>方法基本上都按照调用的先后顺序在各自区块中排列；</p>
</li>
<li><p>相关功能作为小区块放在一起（或者封装掉）；</p>
</li>
<li><p>当一个类有多个构造函数，或是多个同名函数，这些函数应该按顺序出现在一起，中间不要放进其它函数；</p>
</li>
<li><p>数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个 <code>DataManager</code>，把 <code>http</code>、<code>preference</code>、<code>eventpost</code>、<code>database</code> 都放在 <code>DataManager</code> 里面进行操作，我们只需要与 DataManager打交道；</p>
</li>
<li><p>多用组合，少用继承；</p>
</li>
<li><p>提取方法，去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。</p>
</li>
<li><p>可引入 <code>Dagger2</code> 减少模块之间的耦合性。<code>Dagger2</code> 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块；</p>
</li>
<li><p>项目引入 <code>RxAndroid</code> 响应式编程，可以极大的减少逻辑代码；</p>
</li>
<li><p>通过引入事件总线，如：<code>EventBus</code>、<code>AndroidEventBus</code>、<code>RxBus</code>，它允许我们在 <code>DataLayer</code> 中发送事件，以便 <code>ViewLayer</code> 中的多个组件都能够订阅到这些事件，减少回调；</p>
</li>
<li><p>尽可能使用局部变量；</p>
</li>
<li><p>及时关闭流；</p>
</li>
<li><p>尽量减少对变量的重复计算；</p>
<p>如下面的操作：</p>
<pre><code>for (int i = 0; i &lt; list.size(); i++) {
      ...
}
</code></pre><p>建议替换为：</p>
<pre><code>for (int i = 0, len = list.size(); i &lt; len; i++) {
      ...
}
</code></pre></li>
<li><p>尽量采用懒加载的策略，即在需要的时候才创建；</p>
<p>例如：</p>
<pre><code>String str = &quot;aaa&quot;;
if (i == 1) {
      list.add(str);
}
</code></pre><p>建议替换为：</p>
<pre><code>if (i == 1) {
      String str = &quot;aaa&quot;;
      list.add(str);
}
</code></pre></li>
<li><p>不要在循环中使用 <code>try…catch…</code>，应该把其放在最外层；</p>
</li>
<li><p>使用带缓冲的输入输出流进行 IO 操作；</p>
</li>
<li><p>尽量使用 <code>HashMap</code>、<code>ArrayList</code>、<code>StringBuilder</code>，除非线程安全需要，否则不推荐使用 <code>HashTable</code>、<code>Vector</code>、<code>StringBuffer</code>，后三者由于使用同步机制而导致了性能开销；</p>
</li>
<li><p>尽量在合适的场合使用单例；</p>
<p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<ol>
<li><p>控制资源的使用，通过线程同步来控制资源的并发访问。</p>
</li>
<li><p>控制实例的产生，以达到节约资源的目的。</p>
</li>
<li><p>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</p>
</li>
</ol>
</li>
<li><p>把一个基本数据类型转为字符串，<code>基本数据类型.toString()</code> 是最快的方式，<code>String.valueOf(数据)</code> 次之，<code>数据 + &quot;&quot;</code> 最慢；</p>
</li>
<li><p>使用 AS 自带的 Lint 来优化代码结构（什么，你不会？右键 module、目录或者文件，选择 Analyze -&gt; Inspect Code）；</p>
</li>
<li><p>最后不要忘了内存泄漏的检测；</p>
</li>
</ol>
<hr>
<p>最后啰嗦几句：</p>
<ul>
<li>好的命名规则能够提高代码质量，使得新人加入项目的时候降低理解代码的难度；</li>
<li>规矩终究是死的，适合团队的才是最好的；</li>
<li>命名规范需要团队一起齐心协力来维护执行，在团队生活里，谁都不可能独善其身；</li>
<li>一开始可能会有些不习惯，持之以恒，总会成功的。</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="UI-控件缩写表"><a href="#UI-控件缩写表" class="headerlink" title="UI 控件缩写表"></a>UI 控件缩写表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>Button</td>
<td>btn</td>
</tr>
<tr>
<td>CheckBox</td>
<td>cb</td>
</tr>
<tr>
<td>EditText</td>
<td>et</td>
</tr>
<tr>
<td>FrameLayout</td>
<td>fl</td>
</tr>
<tr>
<td>GridView</td>
<td>gv</td>
</tr>
<tr>
<td>ImageButton</td>
<td>ib</td>
</tr>
<tr>
<td>ImageView</td>
<td>iv</td>
</tr>
<tr>
<td>LinearLayout</td>
<td>ll</td>
</tr>
<tr>
<td>ListView</td>
<td>lv</td>
</tr>
<tr>
<td>ProgressBar</td>
<td>pb</td>
</tr>
<tr>
<td>RadioButtion</td>
<td>rb</td>
</tr>
<tr>
<td>RecyclerView</td>
<td>rv</td>
</tr>
<tr>
<td>RelativeLayout</td>
<td>rl</td>
</tr>
<tr>
<td>ScrollView</td>
<td>sv</td>
</tr>
<tr>
<td>SeekBar</td>
<td>sb</td>
</tr>
<tr>
<td>Spinner</td>
<td>spn</td>
</tr>
<tr>
<td>TextView</td>
<td>tv</td>
</tr>
<tr>
<td>ToggleButton</td>
<td>tb</td>
</tr>
<tr>
<td>VideoView</td>
<td>vv</td>
</tr>
<tr>
<td>WebView</td>
<td>wv</td>
</tr>
</tbody>
</table>
<h3 id="常见的英文单词缩写表"><a href="#常见的英文单词缩写表" class="headerlink" title="常见的英文单词缩写表"></a>常见的英文单词缩写表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>average</td>
<td>avg</td>
</tr>
<tr>
<td>background</td>
<td>bg（主要用于布局和子布局的背景）</td>
</tr>
<tr>
<td>buffer</td>
<td>buf</td>
</tr>
<tr>
<td>control</td>
<td>ctrl</td>
</tr>
<tr>
<td>current</td>
<td>cur</td>
</tr>
<tr>
<td>default</td>
<td>def</td>
</tr>
<tr>
<td>delete</td>
<td>del</td>
</tr>
<tr>
<td>document</td>
<td>doc</td>
</tr>
<tr>
<td>error</td>
<td>err</td>
</tr>
<tr>
<td>escape</td>
<td>esc</td>
</tr>
<tr>
<td>icon</td>
<td>ic（主要用在 App 的图标）</td>
</tr>
<tr>
<td>increment</td>
<td>inc</td>
</tr>
<tr>
<td>information</td>
<td>info</td>
</tr>
<tr>
<td>initial</td>
<td>init</td>
</tr>
<tr>
<td>image</td>
<td>img</td>
</tr>
<tr>
<td>Internationalization</td>
<td>I18N</td>
</tr>
<tr>
<td>length</td>
<td>len</td>
</tr>
<tr>
<td>library</td>
<td>lib</td>
</tr>
<tr>
<td>message</td>
<td>msg</td>
</tr>
<tr>
<td>password</td>
<td>pwd</td>
</tr>
<tr>
<td>position</td>
<td>pos</td>
</tr>
<tr>
<td>previous</td>
<td>pre</td>
</tr>
<tr>
<td>selector</td>
<td>sel（主要用于某一 view 多种状态，不仅包括 ListView 中的 selector，还包括按钮的 selector）</td>
</tr>
<tr>
<td>server</td>
<td>srv</td>
</tr>
<tr>
<td>string</td>
<td>str</td>
</tr>
<tr>
<td>temporary</td>
<td>tmp</td>
</tr>
<tr>
<td>window</td>
<td>win</td>
</tr>
</tbody>
</table>
<p>程序中使用单词缩写原则：不要用缩写，除非该缩写是约定俗成的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="http://www.ayqy.net/blog/android%E5%8C%85%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener"><strong><font color="#69f">Android 包命名规范</font></strong></a></p>
</li>
<li><p><a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="noopener"><strong><font color="#69f">Android 开发最佳实践</font></strong></a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/0a984f999592" target="_blank" rel="noopener"><strong><font color="#69f">Android 编码规范</font></strong></a></p>
</li>
<li><p><a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E7%BA%AA%E5%BF%B5%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener"><strong><font color="#69f">阿里巴巴 Java 开发手册</font></strong></a></p>
</li>
<li><p><a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="noopener"><strong><font color="#69f">Project and code style guidelines</font></strong></a></p>
</li>
<li><p><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener"><strong><font color="#69f">Google Java 编程风格指南</font></strong></a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/436943216526" target="_blank" rel="noopener"><strong><font color="#69f">小细节，大用途，35 个 Java 代码性能优化总结！</font></strong></a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/2018-01-11-Android的-so文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/2018-01-11-Android的-so文件/" itemprop="url">Android的.so文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T17:05:25+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>Android的.so文件、ABI和CPU的关系</strong></li>
<li><strong>B</strong></li>
<li><strong>C</strong></li>
</ol>
<hr>
<h3 id="Android的-so文件"><a href="#Android的-so文件" class="headerlink" title="Android的.so文件"></a>Android的.so文件</h3><p>早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？7种！</p>
<p>Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。</p>
<p>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。</p>
<h4 id="为什么你需要重点关注-so文件"><a href="#为什么你需要重点关注-so文件" class="headerlink" title="为什么你需要重点关注.so文件"></a>为什么你需要重点关注.so文件</h4><p>如果项目中使用到了NDK，它将会生成.so文件，因此显然你已经在关注它了。如果只是使用Java语言进行编码，你可能在想不需要关注.so文件了吧，因为Java是跨平台的。但事实上，即使你在项目中只是使用Java语言，很多情况下，你可能并没有意识到项目中依赖的函数库或者引擎库里面已经嵌入了.so文件，并依赖于不同的ABI。</p>
<p>例如，项目中使用RenderScript支持库，OpenCV，Unity，android-gif-drawable，SQLCipher等，你都已经在生成的APK文件中包含.so文件了，而你需要关注.so文件。</p>
<p>Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/191937-caeb25d4ab0df30d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p><a href="https://link.jianshu.com/?t=https://play.google.com/store/apps/details?id=com.xh.nativelibsmonitor.app" target="_blank" rel="noopener">Native Libs Monitor</a> 这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。</p>
<blockquote>
<p>当然，我们也可以自己对app反编译来获取这些信息，不过相对麻烦一些。</p>
</blockquote>
<p>很多设备都支持多于一种的ABI。例如ARM64和x86设备也可以同时运行armeabi-v7a和armeabi的二进制包。但最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。</p>
<p>我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的话。</p>
<h4 id="App中可能出错的地方"><a href="#App中可能出错的地方" class="headerlink" title="App中可能出错的地方"></a>App中可能出错的地方</h4><p>处理.so文件时有一条简单却并不知名的重要法则。</p>
<p>你应该尽可能的提供专为每个ABI优化过的.so文件，但要么全部支持，要么都不支持：你不应该混合着使用。你应该为每个ABI目录提供对应的.so文件。</p>
<p>当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支持armeabi-v7a和armeabi）。</p>
<h4 id="其他地方也可能出错"><a href="#其他地方也可能出错" class="headerlink" title="其他地方也可能出错"></a>其他地方也可能出错</h4><p>当你引入一个.so文件时，不止影响到CPU架构。我从其他开发者那里可以看到一系列常见的错误，其中最多的是”UnsatisfiedLinkError”，”dlopen: failed”以及其他类型的crash或者低下的性能：</p>
<h4 id="使用android-21平台版本编译的-so文件运行在android-15的设备上"><a href="#使用android-21平台版本编译的-so文件运行在android-15的设备上" class="headerlink" title="使用android-21平台版本编译的.so文件运行在android-15的设备上"></a>使用android-21平台版本编译的.so文件运行在android-15的设备上</h4><p>使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容的，而是前向兼容的。推荐使用app的minSdkVersion对应的编译平台。</p>
<p>这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。</p>
<h4 id="混合使用不同C-运行时编译的-so文件"><a href="#混合使用不同C-运行时编译的-so文件" class="headerlink" title="混合使用不同C++运行时编译的.so文件"></a>混合使用不同C++运行时编译的.so文件</h4><p>.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。作为一个经验法则，当只有一个.so文件时，静态编译C++运行时是没问题的，否则当存在多个.so文件时，应该让所有的.so文件都动态链接相同的C++运行时。</p>
<p>这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。</p>
<h4 id="没有为每个支持的CPU架构提供对应的-so文件"><a href="#没有为每个支持的CPU架构提供对应的-so文件" class="headerlink" title="没有为每个支持的CPU架构提供对应的.so文件"></a>没有为每个支持的CPU架构提供对应的.so文件</h4><p>这一点在前文已经说到了，但你应该真的特别注意它，因为它可能发生在根本没有意识到的情况下。</p>
<p>例如：你的app支持armeabi-v7a和x86架构，然后使用Android Studio新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构，例如新增android-gif-drawable函数库：</p>
<p><code>compile ‘pl.droidsonroids.gif:android-gif-drawable:1.1.+’</code></p>
<p>发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。</p>
<p>解决方案：重新编译我们的.so文件使其支持缺失的ABIs，或者设置</p>
<p><code>ndk.abiFilters</code></p>
<p>显示指定支持的ABIs。</p>
<p>最后一点：<strong>如果你是一个SDK提供者，但提供的函数库不支持所有的ABIs，那你将会搞砸你的用户，因为他们能支持的ABIs必将只能少于你提供的。</strong></p>
<h4 id="将-so文件放在错误的地方"><a href="#将-so文件放在错误的地方" class="headerlink" title="将.so文件放在错误的地方"></a>将.so文件放在错误的地方</h4><p>我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：</p>
<ul>
<li>Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）</li>
<li>Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录）</li>
<li>AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中）</li>
<li>最终APK文件中的lib/ABI目录中</li>
<li>通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。</li>
</ul>
<h4 id="只提供armeabi架构的-so文件而忽略其他ABIs的"><a href="#只提供armeabi架构的-so文件而忽略其他ABIs的" class="headerlink" title="只提供armeabi架构的.so文件而忽略其他ABIs的"></a>只提供armeabi架构的.so文件而忽略其他ABIs的</h4><p>所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件，因此似乎移除其他ABIs的.so文件是一个减少APK大小的好技巧。但事实上并不是：这不只影响到函数库的性能和兼容性。</p>
<p>x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。</p>
<p>以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ... </span><br><span class="line">    splits &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enable true</span><br><span class="line">            reset()</span><br><span class="line">            include &apos;x86&apos;, &apos;x86_64&apos;, &apos;armeabi-v7a&apos;, &apos;arm64-v8a&apos; //select ABIs to build APKs for</span><br><span class="line">            universalApk true //generate an additional APK that contains all the ABIs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // map for the version code</span><br><span class="line">    project.ext.versionCodes = [&apos;armeabi&apos;: 1, &apos;armeabi-v7a&apos;: 2, &apos;arm64-v8a&apos;: 3, &apos;mips&apos;: 5, &apos;mips64&apos;: 6, &apos;x86&apos;: 8, &apos;x86_64&apos;: 9]</span><br><span class="line"> </span><br><span class="line">    android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        // assign different version code for each output</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            output.versionCodeOverride =</span><br><span class="line">                    project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/cb05698a1968" target="_blank" rel="noopener">https://www.jianshu.com/p/cb05698a1968</a></p>
</blockquote>
<hr>
<h3 id="da"><a href="#da" class="headerlink" title="da"></a>da</h3><hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li><a href="https://apps.evozi.com/apk-downloader/?id=com.xh.nativelibsmonitor.app" target="_blank" rel="noopener">APK Downloader</a> : 便捷下载 Google Play 应用,输入 Google Play 的 App 网址即可下载</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java28-注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java28-注解/" itemprop="url">Java28-注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:08:01+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">一、概念</span><br><span class="line">       注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加，则等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记，就去干相应的事。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。</span><br><span class="line">      比如：@Override 使用在方法上的，表示该方法重写的意思，@Deprecated 使用在方法上，表示该方法废弃的意思</span><br><span class="line"></span><br><span class="line">二、使用</span><br><span class="line">     自定义注解及其应用</span><br><span class="line">    1）、定义一个最简单的注解</span><br><span class="line">            public @interface MyAnnotation &#123;&#125;</span><br><span class="line">    2）、将注解加在某个类上：</span><br><span class="line">            @MyAnnotation</span><br><span class="line">            public class AnnotationTest&#123;</span><br><span class="line">                //......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">三、四种元注解</span><br><span class="line">      Java中提供了四种元注解，专门负责注解其他的注解</span><br><span class="line">    </span><br><span class="line">    1）、@Retention元注解，表示需要在什么级别保存该注释信息（生命周期）。可选的RetentionPoicy参数包括：</span><br><span class="line">         a)、RetentionPolicy.SOURCE: 注解只保留在源文件中</span><br><span class="line">         b)、RetentionPolicy.CLASS：注解只保留在class文件中，在加载到JVM虚拟机时丢弃（默认）</span><br><span class="line">         c)、RetentionPolicy.RUNTIME：内存中的字节码，VM将在运行时也保留注解，因此可以通过反射机制读取注解的信息</span><br><span class="line">    </span><br><span class="line">    2）、@Target元注解，默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括:：</span><br><span class="line">         a)、ElementType.TYPE: 类、接口（包括注解类型)或enum声明</span><br><span class="line">         b)、ElementType.METHOD: 方法声明</span><br><span class="line">         c)、ElementType.FIELD: 成员变量</span><br><span class="line">         d)、ElementType.CONSTRUCTOR: 构造器声明</span><br><span class="line">         e)、ElementType.LOCAL_VARIABLE: 局部变量声明</span><br><span class="line">         f)、 ElementType.PACKAGE: 包声明</span><br><span class="line">         g)、ElementType.PARAMETER: 参数声明</span><br><span class="line">    3）、@Documented元注解，将注解包含在JavaDoc中</span><br><span class="line">    4）、@Inheried元注解，允许子类继承父类中的注解</span><br><span class="line"></span><br><span class="line">四、注解添加属性</span><br><span class="line">    1) 属性：</span><br><span class="line">        基本类型：int id();  </span><br><span class="line">        引用类型：String name(); </span><br><span class="line">        数组类型：int[] values();</span><br><span class="line">        枚举类型：Enum enum();</span><br><span class="line">    2)默认值：default，比如：int id() default 0;   String name() default &quot;haha&quot;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java28-反射机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java28-反射机制/" itemprop="url">Java28-反射机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:07:52+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">一、什么是反射机制</span><br><span class="line">        简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字， 那么就可以通过反射机制来获得类的所有信息。</span><br><span class="line">  </span><br><span class="line">二、哪里用到反射机制</span><br><span class="line">        有些时候，我们用过一些知识，但是并不知道它的专业术语是什么，在刚刚学jdbc时用过一行代码， Class.forName(&quot;com.mysql.jdbc.Driver.class&quot;).newInstance();但是那时候只知道那行代码是生成驱动对象实例，并不知道它的具体含义。听了反射机制这节课后，才知道，原来这就是反射，现在很多开框架都用到反射机制，hibernate、struts都是用反射机制实现的。</span><br><span class="line"></span><br><span class="line">三、反射机制的优点与缺点</span><br><span class="line">        为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念，</span><br><span class="line">  ●  静态编译：在编译时确定类型，绑定对象,即通过。  </span><br><span class="line">  ●  动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。  </span><br><span class="line">        一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</span><br><span class="line">       它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</span><br><span class="line"></span><br><span class="line">四、利用反射机制能获得什么信息</span><br><span class="line">       一句话，类中有什么信息，它就可以获得什么信息，不过前提是得知道类的名字，要不就没有后文了,首先得根据传入的类的全名来创建Class对象。  </span><br><span class="line">        Class c=Class.forName(&quot;className&quot;);          //注明：className必须为全名，也就是得包含包名，比如，com.jimmy.UserInfo;</span><br><span class="line">        Object obj=c.newInstance();                        //创建对象的实例</span><br><span class="line">  </span><br><span class="line">        以下所有的方法全部通过class调用</span><br><span class="line"></span><br><span class="line">    1、获得构造函数的方法  </span><br><span class="line">         Constructor getConstructor(Class[] params)                            //根据指定参数获得public构造器</span><br><span class="line">         Constructor[] getConstructors()                                                //获得public的所有构造器</span><br><span class="line">         Constructor getDeclaredConstructor(Class[] params)             //根据指定参数获得public和非public的构造器</span><br><span class="line">         Constructor[] getDeclaredConstructors()                                 //获得public和非public的所有构造器 </span><br><span class="line"></span><br><span class="line">     2、获得类方法的方法  </span><br><span class="line">         Method getMethod(String name, Class[] params)    //根据方法名，参数类型获得方法</span><br><span class="line">         Method[] getMethods()                                              //获得所有的public方法 </span><br><span class="line">         Method getDeclaredMethod(String name, Class[] params)        //根据方法名和参数类型，获得public和非public的方法</span><br><span class="line">         Method[] getDeclaredMethods()                                                  //获得所以的public和非public方法</span><br><span class="line">   </span><br><span class="line">    3、 获得类中属性的方法</span><br><span class="line">        Field getField(String name)                    //根据变量名得到相应的public变量</span><br><span class="line">        Field[] getFields()                                    //获得类中所以public的变量的方法</span><br><span class="line">        Field getDeclaredField(String name)    //根据方法名获得public和非public变量</span><br><span class="line">        Field[] getDeclaredFields()                    //获得类中所有的public和非public方法 </span><br><span class="line"></span><br><span class="line">注意：一般使用框架用到反射，对默认的架构不满意，重新搭建新的架构</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java27-数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java27-数据库/" itemprop="url">Java27-数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:07:41+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TABLE_NAME 常用指令：</span><br><span class="line">    .help    帮助</span><br><span class="line">    .exit     退出</span><br><span class="line">    .tables    查看表名称</span><br><span class="line">    .schema ***    查看指定表内容</span><br><span class="line">  .headers on    显示列明</span><br><span class="line">  .mode column   左侧居中，调整格式</span><br><span class="line">  .width 10,20,30    调整列之间的距离</span><br><span class="line"></span><br><span class="line">    alter table 表 rename to 表new;    修改表名</span><br><span class="line">    drop table database_name.table_name;    删除表</span><br><span class="line">    insert into 表(列名2,列名3,列名4...) values (属性2,属性3,属性4...)    给表赋值</span><br><span class="line">    insert into 表 values(属性1,属性2,属性3,属性4...)</span><br><span class="line">    select 列1,列2,...或者* from 表    查询</span><br><span class="line">  delete from TABLE where ID=1;    删除行</span><br><span class="line">  update TABLE set 列名=值,列名=值 where 条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    strftime(&apos;格式&apos;,列名)    重定义时间格式</span><br><span class="line">    列名 as 列名new    临时名称</span><br><span class="line">    表1||&apos;我是小三&apos;||表2    拼接表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    INTEGER、REAL、TEXT、BLOB、NULL</span><br><span class="line">    primary key（_id integer primary key autoincrement not null） 主键（autoincrement 自增长）</span><br><span class="line">    not null    非空</span><br><span class="line">    unique    唯一</span><br><span class="line">    check    检测    check sex=&apos;man&apos; or sex=&apos;woman&apos;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">运算符 描述</span><br><span class="line">AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。</span><br><span class="line">BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</span><br><span class="line">EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</span><br><span class="line">IN IN 运算符用于把某个值与一系列指定列表的值进行比较。</span><br><span class="line">NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</span><br><span class="line">LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</span><br><span class="line">GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。</span><br><span class="line">NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。</span><br><span class="line">OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</span><br><span class="line">IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。</span><br><span class="line">IS IS 运算符与 = 相似。</span><br><span class="line">IS NOT IS NOT 运算符与 != 相似。</span><br><span class="line">|| 连接两个不同的字符串，得到一个新的字符串。</span><br><span class="line">UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</span><br><span class="line">LIKE 是大小不敏感</span><br><span class="line">下面一些实例演示了 带有 &apos;%&apos; 和 &apos;_&apos; 运算符的 LIKE 子句不同的地方：</span><br><span class="line">语句 描述</span><br><span class="line">WHERE SALARY LIKE &apos;200%&apos; 查找以 200 开头的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;%200%&apos; 查找任意位置包含 200 的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;_00%&apos; 查找第二位和第三位为 00 的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;2_%_%&apos; 查找以 2 开头，且长度至少为 3 个字符的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;%2&apos; 查找以 2 结尾的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;_2%3&apos; 查找第二位为 2，且以 3 结尾的任意值</span><br><span class="line">WHERE SALARY LIKE &apos;2___3&apos; 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</span><br><span class="line">GLOB 是大小写敏感</span><br><span class="line">下面一些实例演示了 带有 &apos;*&apos; 和 &apos;?&apos; 运算符的 GLOB 子句不同的地方：</span><br><span class="line">语句 描述</span><br><span class="line">WHERE SALARY GLOB &apos;200*&apos; 查找以 200 开头的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;*200*&apos; 查找任意位置包含 200 的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;?00*&apos; 查找第二位和第三位为 00 的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;2??&apos; 查找以 2 开头，且长度至少为 3 个字符的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;*2&apos; 查找以 2 结尾的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;?2*3&apos; 查找第二位为 2，且以 3 结尾的任意值</span><br><span class="line">WHERE SALARY GLOB &apos;2???3&apos; 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</span><br><span class="line">SQLite Limit 子句</span><br><span class="line">SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。</span><br><span class="line">带有 LIMIT 子句的 SELECT 语句的基本语法如下：</span><br><span class="line">SELECT column1, column2, columnN </span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows]</span><br><span class="line">下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法：</span><br><span class="line">SELECT column1, column2, columnN </span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT [no of rows] OFFSET [row num]</span><br><span class="line"></span><br><span class="line">SQLite Order By</span><br><span class="line">SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。</span><br><span class="line">ORDER BY 子句的基本语法如下：</span><br><span class="line">SELECT column-list </span><br><span class="line">FROM table_name </span><br><span class="line">[WHERE condition][ORDER BY column1, column2,.. columnN][ASC | DESC];</span><br><span class="line">SQLite Group By</span><br><span class="line">SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。</span><br><span class="line">在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</span><br><span class="line">下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。</span><br><span class="line">SELECT column-list</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE [ conditions ]</span><br><span class="line">GROUP BY column1, column2....columnN</span><br><span class="line">ORDER BY column1, column2....columnN</span><br><span class="line">您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一、简介</span><br><span class="line">    存储数据的仓库，将一些数据通过数据库结构化的规则进行存储。</span><br><span class="line">    常用的一些数据库的存储：sqlite、oracle、MySQL、SQLDB、DB2。。。包括其他的数据库</span><br><span class="line">    sqlite是Oracle的一个子产品：sqlite是一个轻量级的数据库（sqlite数据库是以文件的方式进行存储）</span><br><span class="line">二、Sqlite的忒点  </span><br><span class="line">  一般大型的数据库都会分配用户的权限，进行对应的管理，有专门的数据库配置文件进行统一管理</span><br><span class="line">    sqlite没有这样的权限管理。要使用sqlite数据库内容，文件copy就可以了，不需要进行导入导出，也没有访问限制</span><br><span class="line"></span><br><span class="line">  1、移植性高，只要文件的copy</span><br><span class="line">  2、存储占用的空间不会太大，也不需要专门数据后台支持</span><br><span class="line">  3、数据库的存储量有限，当存出数据多的时候，访问效率会比较低，一般数据存储量在10万条左右</span><br><span class="line">  4、比如数据库操作过程比较弱，删除表的列，添加列等操作都不支持，对外键的支持比较弱</span><br><span class="line">  5、sqlite开源的，Android设备中，自带的本地数据库就是sqlite(因为消耗内存小)</span><br><span class="line"></span><br><span class="line">三、下载（因为JAVASE没有sqlite）</span><br><span class="line">网址：http://www.sqlite.org/download.html（下载windows版本的tools）</span><br><span class="line">下载的zip压缩包解压缩就可以了</span><br><span class="line">直接可以启动sqlite3看到命令行</span><br><span class="line">补充：如果不能识别sqlite3的命令，配置环境变量Path加入sqlite3.exe所在的完整的文件路径</span><br><span class="line"></span><br><span class="line">四、后续所有对sqlite的操作都是基于命令行的操作</span><br><span class="line">    1.如果直接执行sqlite3的命令行，数据库的内容是存放在内存，没有实际的文件。若将关闭命令行，所有的操作都数据都不再存在。纯粹练练手的</span><br><span class="line">    2.如果要存储到实际的文件中，如何操作？</span><br><span class="line">      a)在任意目录创建一个后缀名是.db的文件（该文件可以用来存放sqlite的数据内容）</span><br><span class="line">      b)通过sqlite3的指令打开该文件，存储数据内容即可 </span><br><span class="line">         指令:sqlite3 *.db文件</span><br><span class="line"></span><br><span class="line">五、使用sqlite3基本指令的介绍</span><br><span class="line">      1.常用的指令：</span><br><span class="line">         .help   帮助</span><br><span class="line">         .exit    退出</span><br><span class="line">        .table   查看数据中创建的所有的表</span><br><span class="line">        .schema  （全部）查看当时创建表的语句，确认有哪些列的名字</span><br><span class="line">        .schema 表名   查看该表的创建语句     </span><br><span class="line">        .headers on      显示列的名字</span><br><span class="line">        .mode column     列默认左侧居中的显示方式</span><br><span class="line"></span><br><span class="line">      2.与数据库操作有关的指令（执行对应的sql语句）</span><br><span class="line">         sql语句的含义：结构化查询语言的意思</span><br><span class="line">         分为三种类型：</span><br><span class="line">         1）DDL：数据库定义语句  （主要作用创建数据表，删除数据表，修改数据表的操作）       </span><br><span class="line">         2）DML：数据库操作语句  （主要往数据表添加，删除，修改，查询等）</span><br><span class="line">         3)  DCL: 数据库控制语句 （数据库开启事务，事件回滚的操作等等）</span><br><span class="line"></span><br><span class="line">     3.DDL语句：</span><br><span class="line">        1.数据库中最重要的就是表的资源，组成表由2个基本要素（列名和字段）</span><br><span class="line">           创建表的过程中，定义列的名字和列的数据类型 比如：name字符串  age整数  等等</span><br><span class="line">           扩展：sqlite中有5种数据类型</span><br><span class="line">                     1— integer  整型</span><br><span class="line">                     2— real       浮点型</span><br><span class="line">                     3— text      文本型/字符串类型</span><br><span class="line">                     4— blob     二进制类型</span><br><span class="line">                     5— Null      空</span><br><span class="line">         2.创建表的语句：create table 表名 (列的名字1 列的数据类型1 限制条件1 ,列的名字2 列的数据类型2 限制条件2);</span><br><span class="line">             比如：create table student (name text,age integer，sex text);    //分号结尾表示语句结束了</span><br><span class="line">             补充列录入字段值的限制</span><br><span class="line">             a)primary key   主键  （特点，表示数据的唯一性）规则：主键必须是integer,而且字段的值不能重复 。如果值重复直接报错</span><br><span class="line">             b)not null 非空 （录入的数据不能为空，否则报错）</span><br><span class="line">             c)unique 唯一  （录入的数据内容唯一，不能有重复）</span><br><span class="line">             d)check  检测    (录入数据内容进行检测 ) </span><br><span class="line">                语句格式:check 列名1=内容1 or 列名2=内容2</span><br><span class="line">                比如:  check (sex=&apos;man&apos; or sex=&apos;woman&apos;)</span><br><span class="line">          </span><br><span class="line">            比如：create table student (_id integer primary key autoincrement , name text not null, age integer, sex text check （sex=&apos;man&apos; or sex = &apos;woman&apos;）, score real);</span><br><span class="line">            特殊:autoincrement 自增长的意思，修饰主键，这样录入数据就可以不用考虑主键值的录入了</span><br><span class="line">            </span><br><span class="line">            修改表名字的语句： alter table 表名1 rename to 表名2;  </span><br><span class="line">            删除表语句: drop table 表名;</span><br><span class="line">            表中添加新的列名： alter table 表名 add 字段名 字段类型  限制条件</span><br><span class="line"></span><br><span class="line">       4.DML语句</span><br><span class="line">          1.往数据表中添加数据： insert into 表名 (列名1,列名2,列名3) values (字段值1,字段值2,字段值3)</span><br><span class="line">              比如： insert into student (name,sex,score) values (&apos;zhangsan&apos;,&apos;man&apos;,66.5);</span><br><span class="line">            </span><br><span class="line">          2.查看指定表的所有的数据: select * from 表名     ==    select  列名1,列名2,列名3 from 表名</span><br><span class="line">               补充：*指代了所有的列名</span><br><span class="line">              a)显示指定列的数据（快速通过列名过滤数据）： select  列名1,列名2 from 表名   比如: select _id,name from student;</span><br><span class="line">              b)where语句进行查询: select 列名门  from 表名 where 条件</span><br><span class="line">                  i)支持判断条件：&gt; &lt; =  &gt;= &lt;= !=    比如：select * from student where age &lt;= 20;    select * from student where score&gt;=60;</span><br><span class="line">                  ii)支持算数条件： + - * / %  比如: select * from student where _id+age = 51;</span><br><span class="line">                  iii)支持其他条件：or(或)   and（且）  between 范围1 and 范围2 （在范围1和范围2之间）</span><br><span class="line">                         比如:select * from student where age &gt; 16 or score &gt;80;       只要一个满足就符合要求</span><br><span class="line">                         比如:select * from student where age &gt; 16 and score &gt;80;     全部满足才符合要求</span><br><span class="line">                         比如:select * from student where age between 18 and 20;    在该区间之内（18和20都是包含的）  等同于：where age&gt;=18 and age&lt;=20;</span><br><span class="line">                  iv) distinct(去除重复的数据) </span><br><span class="line">                       比如:select distinct name from student;   //如果名字一样，不显示重复的名字 (比如相同的部门不用反复打印，只要打印几个不同的部门名字就可以了)</span><br><span class="line">                  v)  like (实现模糊查询的功能)</span><br><span class="line">                       语句结构:select 列名 from 表名 where 需要匹配的列的名字 like  &apos;模糊查询的条件(%和_的使用)&apos; </span><br><span class="line">                        比如: select * from student where  name like &apos;ma%&apos;;   //匹配名字是ma开始后面任意内容，所有符合要求的可以查询  （%匹配任意多的字符，0个也可以）                 </span><br><span class="line">                        比如: select * from student where  name like &apos;ma_&apos;;   //匹配名字是ma开始的，后面一个字符的情况，符合要求的可以查询到 （_匹配单一的字符）</span><br><span class="line">                        比如: select * from student where  name like &apos;_ma%&apos;;  //开始匹配一个字符，中间出现ma,结尾匹配任意字符</span><br><span class="line">                c) order by语句（排序，可以根据实际要求进行指定字段的排序）</span><br><span class="line">                        语句结构: select 列名们 from 表名 where 条件  order by  需要排序的列名 asc(升序)/desc(降序)</span><br><span class="line">                        比如: select * from student order by score desc;   (如果字符串排序按照字典次序)</span><br><span class="line">                d) limit 语句 （限制获取的记录条数，数据库查询分页的情况使用比较多）  15(0-14) 15(15-29) 15(30-44)</span><br><span class="line">                        语句结构：select 列名们 from 表名 where 条件 limit  起始记录数(从0开始计算),获取记录的条数   </span><br><span class="line">                        比如：select * from student limit 0,3 (从第一条记录开始，获取3条数据)</span><br><span class="line">                        补充：可以结合order by使用，在排序完成以后进行数据条数的限制获取</span><br><span class="line">                 f) group by语句 （根据某个字段进行分组的操作）</span><br><span class="line">                         语句结构：select 列名们 from 表名 group by  需要分组的列名</span><br><span class="line">                         比如: select * from student group by stu_group;</span><br><span class="line">            3、内部自带的聚合函数的使用</span><br><span class="line">                 count(列名),min(列名),max(列名),sum(列名),avg(列名);</span><br><span class="line">                 比如：select count(*) from student;      可以获取有多少条student的值 (结果)</span><br><span class="line">                           select min(age) from student;     可以获取年龄最小student的值</span><br><span class="line">                           select max(age) from student;     可以获取年龄最大student的值</span><br><span class="line">                           上述的max,min可以作为where的判断条件</span><br><span class="line">                           比如:select * from student where age = (select max(age) from student);</span><br><span class="line">                 后续sum,avg一样的使用方式</span><br><span class="line">    </span><br><span class="line">          3.删除指定的数据：delete from 表名  （清除表内所有的数据）</span><br><span class="line">                                        delete from 表名 where 判断条件    </span><br><span class="line">                                        比如： delete from student where _id=3; (根据主键是3的对应数据进行删除)</span><br><span class="line">                                        当判断条件不成立的时候，删除失败，不会报错的</span><br><span class="line">          4.修改指定的数据：update 表名 set  列名1=修改的值1,列名2=修改的值2 where 条件判断</span><br><span class="line">                          比如：update student set age=50,phonenum=&apos;110&apos; where _id=1; (根据主键是1的对应的数据，修改对应列名所在的内容)</span><br><span class="line"></span><br><span class="line">补充：主外键的概念</span><br><span class="line">1.主键：记录该表数据的唯一性的标识</span><br><span class="line">2.外键： 当前表的某一列记录其他表的主键，该列就称之为外键，定义的名字一般关联表的名字+_id</span><br><span class="line"></span><br><span class="line">如何创建2张表：</span><br><span class="line">1.创建主表 （department）</span><br><span class="line">   create table department (_id integer primary key autoincrement,name text not null);</span><br><span class="line"></span><br><span class="line">2.创建关联主表主键的副表(employee)</span><br><span class="line">   create table employee (_id integer primay key autoincrement, name text not null, salary real, department_id integer, foreign key (department_id)  references  deparment(_id))；</span><br><span class="line">   规则： foreign 外键的列名 references  主表的名字(主表的主键)</span><br><span class="line">   默认情况下sqilte是关闭外键的使用：需要通过命令行手动打开外键的使用  指令:pragma foreign_keys = on;  打开外键的使用 ，如果不打开创建副表foreign不会被识别</span><br><span class="line">   1.可以确认foreign_key 是否代开的情况，输入指令：pragma foreign_keys （通过返回的0或者1进行判断,0是关闭的）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">录入： 主表录入，然后副表的外键关联就可以了</span><br><span class="line">比如主表：insert into department (name) values (&apos;android&apos;);</span><br><span class="line">          insert into department (name) values (&apos;ios&apos;);</span><br><span class="line"></span><br><span class="line">比如副表：insert into employee(name,salary,department_id) values (&apos;jimmy&apos;,3000.0,1);</span><br><span class="line">                 ......</span><br><span class="line"></span><br><span class="line">查询</span><br><span class="line">采用多表联查的方式</span><br><span class="line">select 主表名.列名1，副表名.列名1  from 主表名，副表名;</span><br><span class="line">1.主表1的显示主表1的信息，主表主表2的信息，重复显示</span><br><span class="line">2.多表查询加上查询的条件</span><br><span class="line">     //加入主外键判断条件，过滤数据</span><br><span class="line">     select employee._id,employee.name,employee.salary,department.name from employee,departmentwhere employee.department_id = deparment._id;        </span><br><span class="line">                                 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ● SQLite 简介</span><br><span class="line">本教程帮助您了解什么是 SQLite，它与 SQL 之间的不同，为什么需要它，以及它的应用程序数据库处理方式。</span><br><span class="line">SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎，这是在普及方面的增长，与它的尺寸大小无关。SQLite 源代码不受版权限制。</span><br><span class="line">什么是 SQLite？</span><br><span class="line">SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。</span><br><span class="line">就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。</span><br><span class="line">为什么要用 SQLite？</span><br><span class="line">      ○ 不需要一个单独的服务器进程或操作的系统（无服务器的）。</span><br><span class="line">      ○ SQLite 不需要配置，这意味着不需要安装或管理。</span><br><span class="line">      ○ 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</span><br><span class="line">      ○ SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</span><br><span class="line">      ○ SQLite 是自给自足的，这意味着不需要任何外部的依赖。</span><br><span class="line">      ○ SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</span><br><span class="line">      ○ SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</span><br><span class="line">      ○ SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</span><br><span class="line">      ○ SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</span><br><span class="line"></span><br><span class="line">  ● 在 Windows 上安装 SQLite</span><br><span class="line">      ○ 请访问 SQLite 下载页面，从 Windows 区下载预编译的二进制文件。</span><br><span class="line">      ○ 您需要下载 sqlite-shell-win32-*.zip 和 sqlite-dll-win32-*.zip 压缩文件。</span><br><span class="line">      ○ 创建文件夹 C:\sqlite，并在此文件夹下解压上面两个压缩文件，将得到 sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件。</span><br><span class="line">      ○ 添加 C:\sqlite 到 PATH 环境变量，最后在命令提示符下，使用 sqlite3 命令，将显示如下结果。</span><br><span class="line">历史</span><br><span class="line">      a. 2000 -- D. Richard Hipp 设计 SQLite 是为了不需要管理即可操作程序。</span><br><span class="line">      b. 2000 -- 在八月，SQLite1.0 发布 GNU 数据库管理器（GNU Database Manager）。</span><br><span class="line">      c. 2011 -- Hipp 宣布，向 SQLite DB 添加 UNQl 接口，开发 UNQLite（面向文档的数据库）。</span><br><span class="line">SQLite 局限性</span><br><span class="line">在 SQLite 中，SQL92 不支持的特性如下所示：</span><br><span class="line">特性 描述</span><br><span class="line">RIGHT OUTER JOIN 只实现了 LEFT OUTER JOIN。</span><br><span class="line">FULL OUTER JOIN 只实现了 LEFT OUTER JOIN。</span><br><span class="line">ALTER TABLE 支持 RENAME TABLE 和 ALTER TABLE 的 ADD COLUMN variants 命令，不支持 DROP COLUMN、ALTER COLUMN、ADD CONSTRAINT。</span><br><span class="line">Trigger 支持 支持 FOR EACH ROW 触发器，但不支持 FOR EACH STATEMENT 触发器。</span><br><span class="line">VIEWs 在 SQLite 中，视图是只读的。您不可以在视图上执行 DELETE、INSERT 或 UPDATE 语句。</span><br><span class="line">GRANT 和 REVOKE 可以应用的唯一的访问权限是底层操作系统的正常文件访问权限。</span><br><span class="line">SQLite 命令</span><br><span class="line">与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：</span><br><span class="line">DDL - 数据定义语言</span><br><span class="line">命令 描述</span><br><span class="line">CREATE 创建一个新的表，一个表的视图，或者数据库中的其他对象。</span><br><span class="line">ALTER 修改数据库中的某个已有的数据库对象，比如一个表。</span><br><span class="line">DROP 删除整个表，或者表的视图，或者数据库中的其他对象。</span><br><span class="line">DML - 数据操作语言</span><br><span class="line">命令 描述</span><br><span class="line">INSERT 创建一条记录。</span><br><span class="line">UPDATE 修改记录。</span><br><span class="line">DELETE 删除记录。</span><br><span class="line">DQL - 数据查询语言</span><br><span class="line">命令 描述</span><br><span class="line">SELECT 从一个或多个表中检索某些记录。</span><br><span class="line">  ●</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java26-正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java26-正则表达式/" itemprop="url">Java26-正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:07:32+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">正则表达式语法</span><br><span class="line">字符 说明</span><br><span class="line">\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，&quot;n&quot;匹配字符&quot;n&quot;。&quot;\n&quot;匹配换行符。序列&quot;\\&quot;匹配&quot;\&quot;，&quot;\(&quot;匹配&quot;(&quot;。</span><br><span class="line">^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与&quot;\n&quot;或&quot;\r&quot;之后的位置匹配。</span><br><span class="line">$ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与&quot;\n&quot;或&quot;\r&quot;之前的位置匹配。</span><br><span class="line">* 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配&quot;z&quot;和&quot;zoo&quot;。* 等效于 &#123;0,&#125;。</span><br><span class="line">+ 一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 &#123;1,&#125;。</span><br><span class="line">? 零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。? 等效于 &#123;0,1&#125;。</span><br><span class="line">&#123;n&#125; n 是非负整数。正好匹配 n 次。例如，&quot;o&#123;2&#125;&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。</span><br><span class="line">&#123;n,&#125; n 是非负整数。至少匹配 n 次。例如，&quot;o&#123;2,&#125;&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有 o。&quot;o&#123;1,&#125;&quot;等效于&quot;o+&quot;。&quot;o&#123;0,&#125;&quot;等效于&quot;o*&quot;。</span><br><span class="line">&#123;n,m&#125; M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，&quot;o&#123;1,3&#125;&quot;匹配&quot;fooooood&quot;中的头三个 o。&apos;o&#123;0,1&#125;&apos; 等效于 &apos;o?&apos;。注意：您不能将空格插入逗号和数字之间。</span><br><span class="line">? 当此字符紧随任何其他限定符（*、+、?、&#123;n&#125;、&#123;n,&#125;、&#123;n,m&#125;）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。</span><br><span class="line">. 匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</span><br><span class="line">(pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用&quot;\(&quot;或者&quot;\)&quot;。</span><br><span class="line">(?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符 (|) 组合模式部件的情况很有用。例如，&apos;industr(?:y|ies) 是比 &apos;industry|industries&apos; 更经济的表达式。</span><br><span class="line">(?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&apos;Windows (?=95|98|NT|2000)&apos; 匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows 3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</span><br><span class="line">(?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&apos;Windows (?!95|98|NT|2000)&apos; 匹配&quot;Windows 3.1&quot;中的 &quot;Windows&quot;，但不匹配&quot;Windows 2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</span><br><span class="line">x|y 匹配 x 或 y。例如，&apos;z|food&apos; 匹配&quot;z&quot;或&quot;food&quot;。&apos;(z|f)ood&apos; 匹配&quot;zood&quot;或&quot;food&quot;。</span><br><span class="line">[xyz] 字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。</span><br><span class="line">[^xyz] 反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。</span><br><span class="line">[a-z] 字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</span><br><span class="line">[^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。</span><br><span class="line">\b 匹配一个字边界，即字与空格间的位置。例如，&quot;er\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。</span><br><span class="line">\B 非字边界匹配。&quot;er\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。</span><br><span class="line">\cx 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是&quot;c&quot;字符本身。</span><br><span class="line">\d 数字字符匹配。等效于 [0-9]。</span><br><span class="line">\D 非数字字符匹配。等效于 [^0-9]。</span><br><span class="line">\f 换页符匹配。等效于 \x0c 和 \cL。</span><br><span class="line">\n 换行符匹配。等效于 \x0a 和 \cJ。</span><br><span class="line">\r 匹配一个回车符。等效于 \x0d 和 \cM。</span><br><span class="line">\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</span><br><span class="line">\S 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</span><br><span class="line">\t 制表符匹配。与 \x09 和 \cI 等效。</span><br><span class="line">\v 垂直制表符匹配。与 \x0b 和 \cK 等效。</span><br><span class="line">\w 匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。</span><br><span class="line">\W 与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。</span><br><span class="line">\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\x41&quot;匹配&quot;A&quot;。&quot;\x041&quot;与&quot;\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用 ASCII 代码。</span><br><span class="line">\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\1&quot;匹配两个连续的相同字符。</span><br><span class="line">\n 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</span><br><span class="line">\nm 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</span><br><span class="line">\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</span><br><span class="line">\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java25-JSON解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java25-JSON解析/" itemprop="url">Java25-JSON解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:07:24+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JSON: JavaScript Object Notation(JavaScript 对象表示法)</span><br><span class="line">JSON 是存储和交换文本信息的语法。类似 XML。</span><br><span class="line">JSON 比 XML 更小、更快，更易解析。</span><br><span class="line">什么是 JSON ？</span><br><span class="line">  ● JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）</span><br><span class="line">  ● JSON 是轻量级的文本数据交换格式</span><br><span class="line">  ● JSON 独立于语言 *</span><br><span class="line">  ● JSON 具有自我描述性，更易理解</span><br><span class="line">* JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</span><br><span class="line">JSON - 转换为 JavaScript 对象</span><br><span class="line">JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。</span><br><span class="line">由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。</span><br><span class="line">与 XML 相同之处</span><br><span class="line">  ● JSON 是纯文本</span><br><span class="line">  ● JSON 具有&quot;自我描述性&quot;（人类可读）</span><br><span class="line">  ● JSON 具有层级结构（值中存在值）</span><br><span class="line">  ● JSON 可通过 JavaScript 进行解析</span><br><span class="line">  ● JSON 数据可使用 AJAX 进行传输</span><br><span class="line">与 XML 不同之处</span><br><span class="line">  ● 没有结束标签</span><br><span class="line">  ● 更短</span><br><span class="line">  ● 读写的速度更快</span><br><span class="line">  ● 能够使用内建的 JavaScript eval() 方法进行解析</span><br><span class="line">  ● 使用数组</span><br><span class="line">  ● 不使用保留字</span><br><span class="line">为什么使用 JSON？</span><br><span class="line">对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用：</span><br><span class="line">使用 XML</span><br><span class="line">  ● 读取 XML 文档</span><br><span class="line">  ● 使用 XML DOM 来循环遍历文档</span><br><span class="line">  ● 读取值并存储在变量中</span><br><span class="line">使用 JSON</span><br><span class="line">  ● 读取 JSON 字符串</span><br><span class="line">  ● 用 eval() 处理 JSON 字符串</span><br><span class="line">JSON 语法</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 语法是 JavaScript 语法的子集。</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 语法规则</span><br><span class="line">JSON 语法是 JavaScript 对象表示法语法的子集。</span><br><span class="line">  ● 数据在名称/值对中</span><br><span class="line">  ● 数据由逗号分隔</span><br><span class="line">  ● 花括号保存对象</span><br><span class="line">  ● 方括号保存数组</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 名称/值对</span><br><span class="line">JSON 数据的书写格式是：名称/值对。</span><br><span class="line">名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：</span><br><span class="line">&quot;firstName&quot; : &quot;John&quot;</span><br><span class="line">这很容易理解，等价于这条 JavaScript 语句：</span><br><span class="line">firstName = &quot;John&quot;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 值</span><br><span class="line">JSON 值可以是：</span><br><span class="line">  ● 数字（整数或浮点数）</span><br><span class="line">  ● 字符串（在双引号中）</span><br><span class="line">  ● 逻辑值（true 或 false）</span><br><span class="line">  ● 数组（在方括号中）</span><br><span class="line">  ● 对象（在花括号中）</span><br><span class="line">  ● null</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 对象</span><br><span class="line">JSON 对象在花括号中书写：</span><br><span class="line">对象可以包含多个名称/值对：</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;</span><br><span class="line">这一点也容易理解，与这条 JavaScript 语句等价：</span><br><span class="line">firstName = &quot;John&quot;</span><br><span class="line">lastName = &quot;Doe&quot;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">JSON 数组</span><br><span class="line">JSON 数组在方括号中书写：</span><br><span class="line">数组可包含多个对象：</span><br><span class="line">&#123;</span><br><span class="line">&quot;employees&quot;: [</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">在上面的例子中，对象 &quot;employees&quot; 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/10/Java23-XML解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/Java23-XML解析/" itemprop="url">Java23-XML解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T23:07:15+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.简单介绍（eXtensible Markup Language）</span><br><span class="line">应用于 Web 开发的许多方面，常用于简化数据的存储和共享。</span><br><span class="line">    a).XML（可扩展标记语言）是一种数据交换格式，主要运用在配置文件的构写。</span><br><span class="line">        比如：web.xml </span><br><span class="line">                  还有html格式：&lt;html&gt;&lt;/html&gt;</span><br><span class="line">                  android界面：&lt;TextView /&gt;</span><br><span class="line">                  上述的格式都是基于xml的格式定义的配置信息‘</span><br><span class="line"></span><br><span class="line">2.规范的xml结构</span><br><span class="line">    &lt;根元素 属性&gt;    开始符号&lt;&gt;</span><br><span class="line">        &lt;子元素1 属性&gt;</span><br><span class="line">        &lt;/子元素&gt;</span><br><span class="line">        &lt;子元素2    /&gt;</span><br><span class="line">    &lt;/根元素&gt;    结束符合&lt;/&gt;</span><br><span class="line"></span><br><span class="line">3.解析XML数据格式的几种方式</span><br><span class="line">    1.Pull解析（Sax进化版）</span><br><span class="line">        特性：基于驱动型事件</span><br><span class="line">        优点：和Sax解析相比，不需要从头解析到底，想何时结束就何时结束（更灵活）</span><br><span class="line">                    对驱动事件的标识也进行优化，效率大大提高了</span><br><span class="line">             移动端采用的XML都是基于Pull解析器的解析</span><br><span class="line"></span><br><span class="line">    2.Sax解析</span><br><span class="line">        特点：基于驱动事件的解析，他把所有的标签，属性，内容划分开来，把他们做成驱动时间</span><br><span class="line">                    &lt;根元素&gt;驱动事件1</span><br><span class="line">                    &lt;/根元素&gt;驱动事件2</span><br><span class="line">                    他的解析称为事件解析</span><br><span class="line">        优点：基于是驱动型事件，逐行解析的效果，内存消耗很小（只消耗当前解析的该行）</span><br><span class="line">        缺点：如果解析中出现问题，不能回到原来的驱动事件，只能重新来过（死板一遍过，容错率低）</span><br><span class="line"></span><br><span class="line">    3.Dom解析</span><br><span class="line">        特性：将需要解析的xml文件全部加载到内存中。将所有的标签包括内容转换成树结构</span><br><span class="line">        优点：查找上的速度一般（通过树的节点查找）。添加，删除，修改效率比较高</span><br><span class="line">        缺点：消耗内存（转树形结构的时候，消耗大量内存），移动端都摒弃了该解析方式，只有服务端采用</span><br><span class="line">                  移动端一旦xml数据多的时候，内存消耗特别厉害</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/O1i4dwj.gif" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上图表示下面的 XML 中的一本书：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;bookstore&gt;</span><br><span class="line">&lt;book category=&quot;COOKING&quot;&gt;</span><br><span class="line">&lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;</span><br><span class="line">&lt;author&gt;Giada De Laurentiis&lt;/author&gt;</span><br><span class="line">&lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">&lt;price&gt;30.00&lt;/price&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;book category=&quot;CHILDREN&quot;&gt;</span><br><span class="line">&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;</span><br><span class="line">&lt;author&gt;J K. Rowling&lt;/author&gt;</span><br><span class="line">&lt;year&gt;2005&lt;/year&gt;</span><br><span class="line">&lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;book category=&quot;WEB&quot;&gt;</span><br><span class="line">&lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;</span><br><span class="line">&lt;author&gt;Erik T. Ray&lt;/author&gt;</span><br><span class="line">&lt;year&gt;2003&lt;/year&gt;</span><br><span class="line">&lt;price&gt;39.95&lt;/price&gt;</span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt;</span><br><span class="line">第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（ISO-8859-1 = Latin-1/西欧字符集）。</span><br><span class="line">实例中的根元素是 &lt;bookstore&gt;。文档中的所有 &lt;book&gt; 元素都被包含在 &lt;bookstore&gt; 中。</span><br><span class="line">&lt;book&gt; 元素有 4 个子元素：&lt;title&gt;、&lt;author&gt;、&lt;year&gt;、&lt;price&gt;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">什么是 XML？</span><br><span class="line">  ● XML 指可扩展标记语言（EXtensible Markup Language）。</span><br><span class="line">  ● XML 是一种很像HTML的标记语言。</span><br><span class="line">  ● XML 的设计宗旨是传输数据，而不是显示数据。</span><br><span class="line">  ● XML 标签没有被预定义。您需要自行定义标签。</span><br><span class="line">  ● XML 被设计为具有自我描述性。</span><br><span class="line">  ● XML 是 W3C 的推荐标准。</span><br><span class="line">XML 和 HTML 之间的差异</span><br><span class="line">XML 不是 HTML 的替代。</span><br><span class="line">XML 和 HTML 为不同的目的而设计：</span><br><span class="line">  ● XML 被设计用来传输和存储数据，其焦点是数据的内容。</span><br><span class="line">  ● HTML 被设计用来显示数据，其焦点是数据的外观。</span><br><span class="line">HTML 旨在显示信息，而 XML 旨在传输信息</span><br><span class="line">XML 不会做任何事情</span><br><span class="line">也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。</span><br><span class="line">下面实例是 Jani 写给 Tove 的便签，存储为 XML：</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br><span class="line">上面的这条便签具有自我描述性。它包含了发送者和接受者的信息，同时拥有标题以及消息主体。</span><br><span class="line">但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</span><br><span class="line">XML 无所不在</span><br><span class="line">目前，XML 在 Web 中起到的作用不会亚于一直作为 Web 基石的 HTML。</span><br><span class="line">XML 是各种应用程序之间进行数据传输的最常用的工具。</span><br><span class="line">XML 把数据从 HTML 分离</span><br><span class="line">如果您需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</span><br><span class="line">通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</span><br><span class="line">通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</span><br><span class="line">XML 简化数据共享</span><br><span class="line">在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。</span><br><span class="line">XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。</span><br><span class="line">这让创建不同应用程序可以共享的数据变得更加容易。</span><br><span class="line">XML 简化数据传输</span><br><span class="line">对开发人员来说，其中一项最费时的挑战一直是在互联网上的不兼容系统之间交换数据。</span><br><span class="line">由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</span><br><span class="line">XML 简化平台变更</span><br><span class="line">升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。</span><br><span class="line">XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新的应用程序或新的浏览器。</span><br><span class="line">XML 使您的数据更有用</span><br><span class="line">不同的应用程序都能够访问您的数据，不仅仅在 HTML 页中，也可以从 XML 数据源中进行访问。</span><br><span class="line">通过 XML，您的数据可供各种阅读设备使用（掌上计算机、语音设备、新闻阅读器等），还可以供盲人或其他残障人士使用。</span><br><span class="line">XML 用于创建新的互联网语言</span><br><span class="line">很多新的互联网语言是通过 XML 创建的。</span><br><span class="line">这里有一些实例：</span><br><span class="line">  ● XHTML</span><br><span class="line">  ● 用于描述可用的 Web 服务 的 WSDL</span><br><span class="line">  ● 作为手持设备的标记语言的 WAP 和 WML</span><br><span class="line">  ● 用于新闻 feed 的 RSS 语言</span><br><span class="line">  ● 描述资本和本体的 RDF 和 OWL</span><br><span class="line">  ● 用于描述针针对 Web 的多媒体 的 SMIL</span><br><span class="line">假如开发人员都是理性的</span><br><span class="line">假如他们都是理性的，就让未来的应用程序使用 XML 来交换数据吧。</span><br><span class="line">未来也许会出现某种字处理软件、电子表格程序以及数据库，它们可以使用 XML 格式读取彼此的数据，而不需要使用任何的转换程序。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JamesWong</p>
              <p class="site-description motion-element" itemprop="description">简单即快乐。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JamesWong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
