<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="简单即快乐。">
<meta property="og:type" content="website">
<meta property="og:title" content="JamesWong&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="JamesWong&#39;s Notes">
<meta property="og:description" content="简单即快乐。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JamesWong&#39;s Notes">
<meta name="twitter:description" content="简单即快乐。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>JamesWong's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JamesWong's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/31/2017-03-31 编译指令 Launcher3常用类分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/31/2017-03-31 编译指令 Launcher3常用类分析/" itemprop="url">Android 源码编译指令 Launcher3常用类分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-31T10:50:26+08:00">
                2017-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017-3-31-10-50"><a href="#2017-3-31-10-50" class="headerlink" title="2017/3/31 10:50"></a>2017/3/31 10:50</h2><p>##### </p>
<h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>回顾昨日知识点</strong></li>
<li><strong>Launcher3常用类分析</strong></li>
<li><strong>编译指令</strong></li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Launcher3常用类分析"><a href="#Launcher3常用类分析" class="headerlink" title="Launcher3常用类分析"></a>Launcher3常用类分析</h3><ol>
<li>Launcher：Launcher中常用的Activity</li>
<li>Workspace：抽象的桌面</li>
<li>CellLayout：Workspace的一个子View</li>
<li>FoldIcon：文件夹的图标</li>
<li>BubbleTextView：图标，一个一个快捷方式</li>
<li>ItemInfo：从快捷方式、文件夹、小部件抽象出来的数据模型</li>
<li>LauncherModel：封装的对数据库的操作</li>
<li>LauncherProvider:Launcher的数据库，里面存储一些默认操作</li>
<li>LauncherAppState：初始化一些对象</li>
<li>DragLayout：Launcher layout的rootview 处理拖动事件</li>
<li>DragController：为Drag定义的一个接口</li>
<li>DragVIew：拖动图标的时候跟随手指移动的View</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>adb安装apk<ul>
<li>adb push [apk所在目录] system/app/包：将apk push进手机中</li>
<li>adb shell pm -r [完整包名]：进行安装</li>
</ul>
</li>
<li>SystemProperty </li>
<li>查看设备agent<ul>
<li><a href="http://www.whoishostingthis.com/tools/user-agent/" target="_blank" rel="noopener">http://www.whoishostingthis.com/tools/user-agent/</a></li>
</ul>
</li>
<li>Launcher3单双层切换<ul>
<li>LauncherAppState.isDisableAllApps</li>
</ul>
</li>
<li>adb pull [资料路径] [目标路径]<ul>
<li>导出代码（需要root）</li>
<li>应用databases所在路径（data/data/com.android.launcher3/databases） </li>
</ul>
</li>
<li>vendor文件夹覆盖<ul>
<li>sprocomm_overlays\项目名\相对路径（idh.code下）</li>
</ul>
</li>
<li>通常对项目资源的的修改都是放在覆盖目录下，以实现不同项目的不同需求，同时保持源码的完整性</li>
<li>编译指令<ul>
<li>m：所有资源文件执行搜索操作</li>
<li>mm：Build 当前目录下的模块</li>
<li>mmm：Build 指定目录下的模块</li>
<li>mma：编译当前路径下所有模块，且包含依赖</li>
<li>mmma：编译指定路径下所有模块，且包含依赖</li>
<li>make \：无参数则表示编译整个Android代码</li>
</ul>
</li>
<li>搜索指令<ul>
<li>cgrep：在所有 C/C++ 文件上执行 grep</li>
<li>jgrep：在所有 C/C++ 文件上执行 grep</li>
<li>resgrep：在所有 res/*.xml 文件上执行 grep</li>
<li>mangrep：所有 AndroidManifest.xml 文件执行搜索操作</li>
<li>sepgrep：所有 sepolicy 文件执行搜索操作</li>
<li>sgerp：所有资源文件执行搜索操作</li>
</ul>
</li>
<li>git使用<ul>
<li>解决pull冲突<ul>
<li>git stash：将本地修改保存起来（git stash list查看保存信息）</li>
<li>git pull：更新代码</li>
<li>git stash pop stash@{0}：还原修改内容</li>
</ul>
</li>
</ul>
</li>
<li>git cherry-pick <commit id="">的使用<ul>
<li>可以选择某一个分支中的一个或几个commit(s)来进行操作</li>
<li>例如，假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了。</li>
</ul>
</commit></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/27/2017-03-27-Android开关机动画铃声 修改默认铃声/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/27/2017-03-27-Android开关机动画铃声 修改默认铃声/" itemprop="url">Android开关机动画铃声 修改默认铃声</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-27T10:15:05+08:00">
                2017-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017-3-27-10-15"><a href="#2017-3-27-10-15" class="headerlink" title="2017/3/27 10:15"></a>2017/3/27 10:15</h2><h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>回顾昨日知识点</strong></li>
<li><strong>Android开关机动画铃声</strong></li>
<li><strong>修改默认铃声</strong></li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Android开关机动画铃声"><a href="#Android开关机动画铃声" class="headerlink" title="Android开关机动画铃声"></a>Android开关机动画铃声</h3><ol>
<li>开关机动画的启动<ul>
<li>Android系统在init.rc中定义了很多Service，定义的Service将会被init进程创建，其中的服务包含开机动画</li>
</ul>
</li>
<li>源文件SurfaceFlinger.cpp<ul>
<li>当android系统boot时，开始加载动画和开机铃声<pre><code>status_tSurfaceFlinger::readyToRun()
{
// start boot animation service  
property_set(&quot;ctl.start&quot;, &quot;bootanim&quot;);//  
}
</code></pre></li>
<li>当Android完成boot后，关闭动画和开机铃声<pre><code>voidSurfaceFlinger::bootFinished()  
{  
//stop bootanim service  
property_set(&quot;ctl.stop&quot;, &quot;bootanim&quot;);  
}  
</code></pre></li>
</ul>
</li>
<li><p>bootanimationservice详解</p>
<ul>
<li>所在位置：/frameworks/base/cmds/bootanimation, 主要有两个文件<ul>
<li>bootanimation_main.cpp</li>
<li>bootAnimation.cpp</li>
</ul>
</li>
<li><p>bootanimation_main.cpp是主入口文件</p>
<ul>
<li><p>其主要的功能是根据传进来的参数决定是是要播放开机还是关机动画/铃音，并且启动BootAnimation:<br>BootAnimation.cpp集成自Thread，在创建时会调用readyToRun()-&gt;threadLoop():</p>
<pre><code>int main(intargc, char** argv)  
{  
   // ...  
if(argc &gt; 1){  
   if(!strcmp(argv[1],&quot;shut&quot;))  
  setBoot =false;  
  }  

  if(argc &gt; 2){  
  if(!strcmp(argv[2],&quot;nomp3&quot;))  
  sePaly =false;  
  }  

  if(argc &gt; 3){  
   if(!strcmp(argv[3],&quot;rotate&quot;))  
  setRotated= true;  
  }  

// ...  

sp&lt;BootAnimation&gt;boot = new BootAnimation(setBoot,sePaly,setRotated);  

XLOGD(&quot;joinThreadPool...&quot;);  
IPCThreadState::self()-&gt;joinThreadPool();  
XLOGD(&quot;exit bootanimation...&quot;);  
}  

return 0;  

}  
</code></pre></li>
</ul>
</li>
<li><p>readyToRun() 方法判断/system/media/bootanimation.zip(shutanimaion.zip)是否存在，如果存在，则将 mAndroidAnimation 设置false，这个变量决定threadLoop中调用android（）还是movie（）来具体实现动画的播放。</p>
<pre><code>status_tBootAnimation::readyToRun() {  
……………………………………  
mAndroidAnimation = false;  
   if(bBootOrShutDown){  

status_terr = mZip.open(&quot;/data/local/bootanimation.zip&quot;);  

if(err != NO_ERROR) {  

   err =mZip.open(&quot;/system/media/bootanimation.zip&quot;);  

   if (err != NO_ERROR) {  

   mAndroidAnimation = true;  

   }  

}  

   }else {  

   if(!bShutRotate){  

  status_terr = mZip.open(&quot;/data/local/shutanimation.zip&quot;);  

  if (err != NO_ERROR) {  

  err= mZip.open(&quot;/system/media/shutanimation.zip&quot;);  

  if (err != NO_ERROR) {  

  mAndroidAnimation = true;  

  }  

  }  

   }  

   }  

return NO_ERROR;  

}  
boolBootAnimation::threadLoop()  
{  
//  …................  
   if(!bBootOrShutDown){  

  pSoundFileName=&quot;/data/local/shutaudio.mp3&quot;;  

  pBackupSoundFileName=&quot;/system/media/shutaudio.mp3&quot;;  

   } else {  

  pSoundFileName=&quot;/data/local/bootaudio.mp3&quot;;  

 pBackupSoundFileName=&quot;/system/media/bootaudio.mp3&quot;;  

   }  

   …...............  

   mediastatus =mediaplayer-&gt;setDataSource(pBackupSoundFileName, NULL);  

   mediaplayer-&gt;setAudioStreamType(AudioSystem::BOOT);  

   mediastatus = mediaplayer-&gt;prepare();  

   mediaplayer-&gt;setAudioStreamType(AudioSystem::BOOT);  

   mediastatus =mediaplayer-&gt;prepare();  

   mediaplayer-&gt;setVolume(0.28,0.28);  

   mediastatus =mediaplayer-&gt;start();  

 …..........................  

   if (mAndroidAnimation）  

  r = &lt;span style=&quot;background-color: rgb(255, 255, 102); &quot;&gt;android&lt;/span&gt;()；  

} else {  

   r = movie();  

   }  

}  
</code></pre></li>
<li>threadLoop首先判断system/media/bootaudio.mp3(shutaudio.mp3)文件是否存在，如果存在则调用mediaplayer的接口播放（setdatasoruce，prepare，setvolume，start）。<br>然后根据 mAndroidAnimation 变量调用android()/movie(). 如果system/media/shutanimation.zip/bootanimation.zip存在的话，调用movie（），该接口会解析zip文件中的desc.txt文件，根据txt文件中的配置来播放动画。</li>
</ul>
</li>
<li>bootanimation.zip中desc.txt播放规则<ul>
<li>1920 1080 15 —-第一位宽 第二位是高 第三位是帧率也就是一秒播放多少帧(多少张图片)</li>
<li>p 1 0 part1—-第二位表示part1部分也就是包含图片的文件夹播放次数，第二位表示这部分播完后下部分开始的间隔，默认为0第三位表示文件夹名称</li>
<li><strong>在编写完你所需要的设置后，最后一行要换行，切记，否则系统无法读取开机广告</strong></li>
<li><img src="http://i.imgur.com/ASKTvQM.png" alt=""></li>
<li><strong>zip资源是以存储的形式打包</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>修改默认铃声需要更改的几个位置<ul>
<li>资源：frameworks\base\data\sounds</li>
<li>mk资源列表：frameworks\base\data\sounds</li>
<li>默认铃声：build\buildplus\buildspec\对应项目spec、RO_CONFIG_RINGTONE</li>
<li>如果需要针对不同机型，需要在devices\sprd\sounds.mk中进行资源文件夹的选择判断</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/20/2017-03-20 Android Preference实践 Ubuntu jdk8环境配置添加 @hide方法注释/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/20/2017-03-20 Android Preference实践 Ubuntu jdk8环境配置添加 @hide方法注释/" itemprop="url">Android Preference实践 Ubuntu jdk8环境配置添加 @hide方法注释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-20T12:47:58+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>回顾昨日知识点</strong></li>
<li><strong>Preference</strong></li>
<li><strong>Ubuntu jdk8环境配置添加</strong></li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><ol>
<li>自己写一个类TextPreference，继承Preference,调用自定义布局文件如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:title=&quot;@string/storage_settings_title&quot; &gt;</span><br><span class="line">    &lt;PreferenceCategory</span><br><span class="line">        android:key=&quot;phone_memory_category&quot;</span><br><span class="line">        android:title=&quot;@string/storage_settings_title&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.android.settings.deviceinfo.TextPreference //自定义类</span><br><span class="line">        android:fragment=&quot;com.android.settings.deviceinfo.Memory&quot;</span><br><span class="line">        android:key=&quot;phone_memory_ll&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;/PreferenceCategory&gt;</span><br><span class="line">&lt;/PreferenceScreen&gt;</span><br></pre></td></tr></table></figure>
<p>在TextPreference类里面复写onCreateView方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected View onCreateView(ViewGroup parent) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">	View layout = inflater.inflate(R.layout.phone_memory_linear_layout, null);</span><br><span class="line">	mMaxTitle = (TextView)layout.findViewById(R.id.max_title);</span><br><span class="line">	return layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-jdk8环境配置添加"><a href="#Ubuntu-jdk8环境配置添加" class="headerlink" title="Ubuntu jdk8环境配置添加"></a>Ubuntu jdk8环境配置添加</h3><ol>
<li>环境安装<ul>
<li>在代码idh.code\build\jdk文件夹下有安装包</li>
<li>安装openjdk8<br><code>sudo dpkg -i openjdk-8-jdk_8u45-b14-1_amd64.deb openjdk-8-jre_8u45-b14-1_amd64.deb openjdk-8-jre-headless_8u45-b14-1_amd64.deb</code></li>
<li>安装完上一步中的jdk后，系统的java版本会被替换为openjdk8, 为兼容6.0/5.1的编译，需要把jdk换回来（设置好后会在当前的java版本前有个*号，确保为java-7）<br><code>sudo update-alternatives --config java</code><br><code>sudo update-alternatives --config javac</code><br><code>sudo update-alternatives --config javah</code><br><code>sudo update-alternatives --config javadoc</code><br><code>sudo update-alternatives --config javap</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>X50142机器不识别<ul>
<li>USB模式设为virtual drive</li>
<li>识别出设备安装驱动</li>
<li>usb改vid，C:\Users\用户.android下，adb_usb.ini文件中加上0x1BBB，重启adb</li>
</ul>
</li>
<li>X50142全编不成功<ul>
<li>jdk1.8<ul>
<li>要先update，sudo apt-get update</li>
<li>sudo apt-get install openjdk-8-jdk</li>
</ul>
</li>
<li>提示<ul>
<li><img src="http://i.imgur.com/TZOKAxX.png" alt=""></li>
<li>sudo apt-get install mkisofs</li>
</ul>
</li>
</ul>
</li>
<li>以/<em>*@hide</em>/注释的API为隐藏，就算是public也是无法被调用的，可以用反射机制进行调用</li>
<li>adb查看log<ul>
<li>adb logcat -c 清除</li>
<li>adb logcat -s 过滤搜索</li>
<li>fatal：崩溃信息</li>
</ul>
</li>
<li><p>导入三方apk</p>
<ul>
<li><p>vendor\ThirdpartApp\对应项目</p>
<ul>
<li>apk</li>
<li><p>Android.mk</p>
<ul>
<li>选择相应的项目名</li>
<li>添加apk的include</li>
<li><p>System\App:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := Xender</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_SRC_FILES := 3rd_APKs/xender_intex_india_1_3.4.0419_20170208.apk</span><br><span class="line">LOCAL_MODULE_CLASS := APPS</span><br><span class="line">LOCAL_DEX_PREOPT := true</span><br><span class="line">LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)</span><br><span class="line">LOCAL_CERTIFICATE := PRESIGNED</span><br></pre></td></tr></table></figure>
</li>
<li><p>System/Priv-app:添加 <code>LOCAL_PRIVILEGED_MODULE := true</code></p>
</li>
<li>Uninstall mode:添加 <code>LOCAL_MODULE_PATH := $(TARGET_OUT)/preloadapp</code></li>
</ul>
</li>
<li>install.mk:添加<code>Android.mk</code>中相应<code>MODULE</code>名</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/18/2017-03-18-RxJava-学习整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/18/2017-03-18-RxJava-学习整理/" itemprop="url">RxJava 学习整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-18T12:44:39+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="RxJava学习"><a href="#RxJava学习" class="headerlink" title="RxJava学习"></a>RxJava学习</h3><ol>
<li>RxJava<ul>
<li>是什么:<strong>异步</strong></li>
<li>好在哪:<strong>简洁</strong></li>
</ul>
</li>
<li>API介绍和原理简析<ul>
<li>RxJava的异步实现，是通过一种<strong>扩展的观察者模式</strong>来实现的</li>
<li><img src="http://i.imgur.com/f4cgZhK.jpg" alt=""></li>
<li><img src="http://i.imgur.com/O4IzraD.jpg" alt=""><ul>
<li><strong>基本概念</strong>：Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件通知Observer<ul>
<li>Observable：可观察者，即被观察者</li>
<li>Observer：观察者</li>
<li>subscribe：订阅、事件</li>
</ul>
</li>
<li><strong>事件回调方法</strong><ul>
<li><img src="http://i.imgur.com/sT9ZQb9.jpg" alt=""></li>
<li>onNext()：相当于onClick()/onEvent()</li>
<li>onCompleted()：事件队列完结。RxJava不仅把每个时间单独处理，还会把它们看做一个队列。RxJava规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。</li>
<li>onError()：事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时终止队列，不允许再有事件发出</li>
<li>onCompleted()与onError()方法必触发一个，且只触发一个</li>
</ul>
</li>
<li><strong>RxJava基本实现步骤</strong><ul>
<li><img src="http://i.imgur.com/Aq3Ih36.jpg" alt=""></li>
</ul>
<ol>
<li>创建Observer（它决定事件触发的时候将有怎样的行为）<ul>
<li><img src="http://i.imgur.com/6rJOnz1.png" alt=""></li>
<li><strong>Oberver和Subscriber不同点</strong>(Subscriber是Oberver的扩展)<ul>
<li>onStart()：这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。</li>
<li>unsubscribe()：这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</li>
</ul>
</li>
</ul>
</li>
<li>创建Observable（它决定什么时候触发事件以及触发怎样的事件，用<code>create()</code>方法创建） <ul>
<li><img src="http://i.imgur.com/f1XaTqP.png" alt=""></li>
<li>参数OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发。</li>
<li><strong>RxJava创造事件序列的方法</strong>(三者等价)<ul>
<li><code>create()</code></li>
<li><code>just(T...)</code>：将传入的参数依次发出</li>
<li><code>from(T[])</code>/<code>from(Iterable&lt;? extends T&gt;)</code>：将传入的数组或Iterable拆分成具体对象，依次发出</li>
</ul>
</li>
</ul>
</li>
<li>Subscribe(订阅)<ul>
<li><img src="http://i.imgur.com/Q45n2gZ.png" alt=""></li>
</ul>
</li>
<li>实例<ul>
<li><img src="http://i.imgur.com/dtR95Ph.png" alt=""></li>
<li><img src="http://i.imgur.com/5HzRlC3.png" alt=""></li>
<li><img src="http://i.imgur.com/Oedxw8A.png" alt=""></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>线程控制–Scheduler<ul>
<li>subscribeOn() 和 observeOn() 两个方法来对线程进行控制<ul>
<li><strong>subscribeOn()</strong>: 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程</li>
<li><strong>observeOn()</strong>: 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程</li>
<li><code>Schedulers.immediate()</code>：默认，在当前线程运行</li>
<li><code>Schedulers.newThread()</code>：总是启用新线程，并在新线程执行操作</li>
<li><code>Schedulers.io()</code>：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>：计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li><code>AndroidSchedulers.mainThread()</code>：在 Android 主线程运行</li>
</ul>
</li>
<li>实例<ul>
<li><img src="http://i.imgur.com/ZuO9HVt.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>变换<ul>
<li><code>map()</code>:事件对象的直接变换<ul>
<li><img src="http://i.imgur.com/5vPVGS6.png" alt=""></li>
</ul>
</li>
<li><code>flatmap()</code>: flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。<ul>
<li><img src="http://i.imgur.com/51zSBq6.png" alt=""></li>
<li><img src="http://i.imgur.com/1aiqX8s.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考 : <a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/18/RxJava整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/18/RxJava整理/" itemprop="url">RxJava整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-18T10:13:25+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="RxJava学习"><a href="#RxJava学习" class="headerlink" title="RxJava学习"></a>RxJava学习</h3><ol>
<li>RxJava<ul>
<li>是什么:<strong>异步</strong></li>
<li>好在哪:<strong>简洁</strong></li>
</ul>
</li>
<li>API介绍和原理简析<ul>
<li>RxJava的异步实现，是通过一种<strong>扩展的观察者模式</strong>来实现的</li>
<li><img src="http://i.imgur.com/f4cgZhK.jpg" alt=""></li>
<li><img src="http://i.imgur.com/O4IzraD.jpg" alt=""><ul>
<li><strong>基本概念</strong>：Observable和Observer通过subscribe()方法实现订阅关系，从而Observable可以在需要的时候发出事件通知Observer<ul>
<li>Observable：可观察者，即被观察者</li>
<li>Observer：观察者</li>
<li>subscribe：订阅、事件</li>
</ul>
</li>
<li><strong>事件回调方法</strong><ul>
<li><img src="http://i.imgur.com/sT9ZQb9.jpg" alt=""></li>
<li>onNext()：相当于onClick()/onEvent()</li>
<li>onCompleted()：事件队列完结。RxJava不仅把每个时间单独处理，还会把它们看做一个队列。RxJava规定，当不会再有新的onNext()发出时，需要触发onCompleted()方法作为标志。</li>
<li>onError()：事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时终止队列，不允许再有事件发出</li>
<li>onCompleted()与onError()方法必触发一个，且只触发一个</li>
</ul>
</li>
<li><strong>RxJava基本实现步骤</strong><ul>
<li><img src="http://i.imgur.com/Aq3Ih36.jpg" alt=""></li>
</ul>
<ol>
<li>创建Observer（它决定事件触发的时候将有怎样的行为）<ul>
<li><img src="http://i.imgur.com/6rJOnz1.png" alt=""></li>
<li><strong>Oberver和Subscriber不同点</strong>(Subscriber是Oberver的扩展)<ul>
<li>onStart()：这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。</li>
<li>unsubscribe()：这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</li>
</ul>
</li>
</ul>
</li>
<li>创建Observable（它决定什么时候触发事件以及触发怎样的事件，用<code>create()</code>方法创建） <ul>
<li><img src="http://i.imgur.com/f1XaTqP.png" alt=""></li>
<li>参数OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发。</li>
<li><strong>RxJava创造事件序列的方法</strong>(三者等价)<ul>
<li><code>create()</code></li>
<li><code>just(T...)</code>：将传入的参数依次发出</li>
<li><code>from(T[])</code>/<code>from(Iterable&lt;? extends T&gt;)</code>：将传入的数组或Iterable拆分成具体对象，依次发出</li>
</ul>
</li>
</ul>
</li>
<li>Subscribe(订阅)<ul>
<li><img src="http://i.imgur.com/Q45n2gZ.png" alt=""></li>
</ul>
</li>
<li>实例<ul>
<li><img src="http://i.imgur.com/dtR95Ph.png" alt=""></li>
<li><img src="http://i.imgur.com/5HzRlC3.png" alt=""></li>
<li><img src="http://i.imgur.com/Oedxw8A.png" alt=""></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>线程控制–Scheduler<ul>
<li>subscribeOn() 和 observeOn() 两个方法来对线程进行控制<ul>
<li><strong>subscribeOn()</strong>: 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程</li>
<li><strong>observeOn()</strong>: 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程</li>
<li><code>Schedulers.immediate()</code>：默认，在当前线程运行</li>
<li><code>Schedulers.newThread()</code>：总是启用新线程，并在新线程执行操作</li>
<li><code>Schedulers.io()</code>：I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>：计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li><code>AndroidSchedulers.mainThread()</code>：在 Android 主线程运行</li>
</ul>
</li>
<li>实例<ul>
<li><img src="http://i.imgur.com/ZuO9HVt.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>变换<ul>
<li><code>map()</code>:事件对象的直接变换<ul>
<li><img src="http://i.imgur.com/5vPVGS6.png" alt=""></li>
</ul>
</li>
<li><code>flatmap()</code>: flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。<ul>
<li><img src="http://i.imgur.com/51zSBq6.png" alt=""></li>
<li><img src="http://i.imgur.com/1aiqX8s.jpg" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1. </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/2017-03-15-bugreport基本信息-ViewPage中fragment替换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/15/2017-03-15-bugreport基本信息-ViewPage中fragment替换/" itemprop="url">bugreport基本信息 ViewPage中fragment替换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T12:43:24+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>bugreport<ul>
<li>frameworks/base/cmds/bugreport</li>
<li>启动dumpstatus服务，并通过socket连接，读取信息，并保持到stdout管道中</li>
<li><strong>SystemProperties.set(“ctl.start”, “bugreport”);</strong></li>
</ul>
</li>
<li>dumpstatus<ul>
<li>frameworks/native/cmds/dumpstatus</li>
<li>android的相关信息,内核，进程，相关信息的主要实现地方。</li>
<li>dumpstatus主要信息<ol>
<li>基本信息，如版本信息，内存基本信息，cpu基本信息，硬件信息等</li>
<li>系统log</li>
<li>网络信息，路由信息，网络配置信息</li>
<li>panic信息</li>
<li>锁的使用信息</li>
<li>进程信息</li>
<li>binder信息</li>
<li>应用程序安装信息</li>
<li>磁盘使用情况</li>
<li>所有activity，services信息等</li>
<li>properties信息等</li>
</ol>
</li>
</ul>
</li>
<li>dumpsys<ul>
<li>frameworks/native/cmds/dumpysy</li>
<li>获取android服务进程的各个信息,比如dumpsys media.audio_policy 等</li>
</ul>
</li>
<li><p>ViewPager中Fragment的替换</p>
<ul>
<li>正常来说viewpager在加载当前页的时候已经将pager页左右页的内容加载进内存里了，这样才保证了viewpager左右滑动的时候的流畅性，只要加载过，fragment中的视图就一直在内存中，在这个过程中无论你怎么刷新，清除都是无用的，直至程序退出；</li>
<li>可以把适配器换成FragmentStatePagerAdapter，重写getItemPosition方法实现动态替换ViewPager中的Fragment<ul>
<li><img src="http://i.imgur.com/mFu5Kjk.png" alt=""></li>
</ul>
</li>
<li><p>The first option is easier, but bit more inefficient.</p>
</li>
<li><p>Override getItemPosition in your PagerAdapter like this:</p>
</li>
<li><p>public int getItemPosition(Object object) {<br>return POSITION_NONE;<br>}</p>
</li>
<li><p>This way, when you call notifyDataSetChanged(), the view pager will remove all views and reload them all. As so the reload effect is obtained.</p>
</li>
<li><p>The second option, suggested by Alvaro Luis Bustamante (previously alvarolb), is to setTag() method in instantiateItem() when instantiating a new view. Then instead of using notifyDataSetChanged(), you can use findViewWithTag() to find the view you want to update.</p>
</li>
<li><p>The second approach is very flexible and high performant. Kudos to alvarolb for the original research.</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/2017-03-14-Launcher3-代码覆盖插件-签名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/2017-03-14-Launcher3-代码覆盖插件-签名/" itemprop="url">Launcher3 代码覆盖插件 签名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T12:42:16+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017-3-14-9-34"><a href="#2017-3-14-9-34" class="headerlink" title="2017/3/14 9:34"></a>2017/3/14 9:34</h2><h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>回顾昨日知识点</strong></li>
<li><strong>Launcher分析</strong></li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Launcher分析"><a href="#Launcher分析" class="headerlink" title="Launcher分析"></a>Launcher分析</h3><ol>
<li>LauncherProvider<ul>
<li>继承自ContentProvider类，内部基于数据库存储实现了ContentProvider的CRUD接口，这个类主要用于更新数据库的数据。</li>
<li>LauncherProvider内部维护了两张数据表，favorites(用于存储workspace上的内容信息)和workspaceScreens(用于存储screen的排序和页数的信息)。</li>
</ul>
</li>
<li>LauncherModel<ul>
<li>用于维护内存中的数据，通过ContentResolver来更新LauncherProvider的数据，即数据库的数据。</li>
<li><img src="http://i.imgur.com/CJqE68p.png" alt=""><ul>
<li>AppInfo：代表所有应用界面的一个app</li>
<li>FolderInfo：代表一个文件夹</li>
<li>LauncherAppWidgetInfo：代表一个widget</li>
<li>ShortcutInfo：代表workspace和folder里的app</li>
</ul>
</li>
</ul>
</li>
<li>Workspace数据的加载过程<ul>
<li>Launcher3的数据加载分为两部分<ol>
<li>一个是Workspace页面的数据：Launcher最主要的界面，用户可自由编辑内容(widget，app， folder，screen)</li>
<li>第二部分是所有应用界面。</li>
</ol>
</li>
<li>Workspace的数据加载过程，通过在LoaderTask.run()方法里调用loadAndBindWorkspace()开始整个过程（两步load和bind，完成第一步后会判断任务是否终止，如果是则不继续下一步）</li>
<li><img src="http://i.imgur.com/2v5xMLT.png" alt=""></li>
<li>addAppShortcut，addAppWIdget，addAppFolder是把xml获取到的数据insert到数据库中</li>
<li>数据库中的数据存到LauncherModel相应的数据列表里(sBgItemsIdMap，sBgWorkspaceItemsm，sBgAppWidgets，sBgFolders，sBgWorkspaceScreens)</li>
<li>将数据绑定到Launcher界面</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>代码覆盖<ul>
<li>文件覆盖, 在全编时会将sprocomm_proj对应目录下的文件拷贝到原始代码位置, 原来文件的内容被修改</li>
<li>资源覆盖, 在7.0上vendor/sprocomm_res_overlay目录下的资源文件会编译到对应的app中,但原始代码中的文件不会被修改(只是被覆盖的文件不起作用)</li>
</ul>
</li>
<li>平台插件<ul>
<li>在vendor/sprd/plugin目录下有对应的插件, 如果项目中编译了该插件,那么插件中定义的类和资源会在运行时动态加载到主apk中, 主apk的代码文件不会被修改,但在运行时会被插件中被替代而不起作用, 插件主要通过pluginmanager加载.</li>
</ul>
</li>
<li>签名<ul>
<li>签名要对应, debug版本和user版本的签名是不一样的</li>
<li>安装的应用的签名也要一致</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Android源码架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/13/Android源码架构/" itemprop="url">Android源码架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T22:13:49+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android源码架构"><a href="#Android源码架构" class="headerlink" title="Android源码架构"></a>Android源码架构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── Makefile            全局的Makefile</span><br><span class="line">├── build               系统编译规则和配置所需要的脚本和工具</span><br><span class="line">├── prebuilt            各种平台编译工具链</span><br><span class="line">├── bionic              基础C库源代码</span><br><span class="line">├── frameworks          * Android应用程序的核心框架层(java及C++语言)</span><br><span class="line">├── system              * 底层文件系统/库/应用及组件(adb...)</span><br><span class="line">├── dalvik              JAVA虚拟机</span><br><span class="line">├── external            Android使用的一些额外开源库(字体/Bt/Sepolicy...)</span><br><span class="line">├── libcore             与媒体播放框架代码相关</span><br><span class="line">├── packages            各种应用程序实例</span><br><span class="line">├── development         程序开发所需要的实例/模板/工具</span><br><span class="line">├── ndk</span><br><span class="line">├── sdk</span><br><span class="line">├── cts                 Android CTS兼容性规范测试代码</span><br><span class="line">├── vendor              * 厂商定制代码</span><br><span class="line">├── device              * 厂商定制代码</span><br><span class="line">├── hardware            * 一些与硬件相关的库，部分厂家开源的硬解适配层HAL代码</span><br><span class="line">├── kernel              * Linux源代码</span><br><span class="line">├── bootable            引导加载器（LK）</span><br><span class="line">├── abi</span><br><span class="line">├── doc                 * Android相关的文档</span><br><span class="line">├── art                 * art虚拟机相关的代码</span><br><span class="line">├── developers</span><br><span class="line">├── libnativehelper</span><br><span class="line">├── out                 编译生成的文件</span><br><span class="line">├── pdk</span><br></pre></td></tr></table></figure>
<h1 id="BUILD系统"><a href="#BUILD系统" class="headerlink" title="BUILD系统"></a>BUILD系统</h1><p>Android的源码是如何编译的？<br>了解了这个有助于我们对android源码是如何构成的有直观的了解，现在以SC7731C Android7.0为例，在这里对Android编译系统进行分析。</p>
<p>整个build的make文件主要分为三类:   </p>
<ol>
<li>系统核心的Make文件： 定义了Build系统的框架，文件全部位于路径 /build/core ，其他Make文件都是基于该框架编写的；   </li>
<li>针对产品的Make文件： 定义了具体某个型号手机的Make文件，文件路径位于 /device ，该目录下往往又以公司名和产品名划分两个子级目录，比如 /device/qcom/msm8916 ；  </li>
<li>针对模块的Make文件： 整个系统分为各个独立的模块，每个模块都一个专门的Make文件，名称统一为”Android.mk”，该文件定义了当前模块的编译方式。Build系统会扫描整个源码树中名为”Android.mk”的问题，并执行相应模块的编译工作。  </li>
</ol>
<h2 id="Android编译指令"><a href="#Android编译指令" class="headerlink" title="Android编译指令"></a>Android编译指令</h2><p>Android原生的代码完整编译需要如下三个命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">$ lunch</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure></p>
<h3 id="1-source-build-envsetup-sh"><a href="#1-source-build-envsetup-sh" class="headerlink" title="1. source build/envsetup.sh"></a>1. source build/envsetup.sh</h3><blockquote>
<p>第一行命令<code>$ source build/envsetup.sh</code>引入了<code>build/envsetup.sh</code>脚本中的变量和方法，该脚本的作用是初始化编译环境，其中最重要的函数比如lunch就是在这一步加载到shell环境变量中去的。<br>环境导入后,当可以执行lunch函数时，通常有一下命令可被执行。</p>
</blockquote>
<ul>
<li>编译指令</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>croot</td>
<td>切换到源码树的根目录</td>
</tr>
<tr>
<td>m</td>
<td>在源码树的根目录执行 make</td>
</tr>
<tr>
<td>mm</td>
<td>Build 当前目录下的模块</td>
</tr>
<tr>
<td>mmm</td>
<td>Build 指定目录下的模块</td>
</tr>
<tr>
<td>mma</td>
<td>编译当前路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>mmma</td>
<td>编译指定路径下所有模块，且包含依赖</td>
</tr>
<tr>
<td>make \<module\></module\></td>
<td>无参数则表示编译整个Android代码</td>
</tr>
</tbody>
</table>
<ul>
<li>搜索指令</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cgrep</td>
<td>在所有 C/C++ 文件上执行 grep</td>
</tr>
<tr>
<td>jgrep</td>
<td>在所有 Java 文件上执行 grep</td>
</tr>
<tr>
<td>resgrep</td>
<td>在所有 res/*.xml 文件上执行 grep</td>
</tr>
<tr>
<td>mangrep</td>
<td>所有 AndroidManifest.xml 文件执行搜索操作</td>
</tr>
<tr>
<td>sepgrep</td>
<td>所有 sepolicy 文件执行搜索操作</td>
</tr>
<tr>
<td>sgrep</td>
<td>所有资源文件执行搜索操作</td>
</tr>
</tbody>
</table>
<ul>
<li>导航指令</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>croot</td>
<td>切换至Android根目录</td>
</tr>
<tr>
<td>cproj</td>
<td>切换至工程的根目录</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以搭配<code>cd -</code>来回切换</p>
</blockquote>
<ul>
<li>其他指令</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>printconfig</td>
<td>显示当前 Build 的配置信息</td>
</tr>
<tr>
<td>add_lunch_combo</td>
<td>在 lunch 函数的菜单中添加一个条目</td>
</tr>
<tr>
<td>lunch</td>
<td>函数的参数用来指定此次编译的目标产品以及编译类型。</td>
</tr>
</tbody>
</table>
<p>如下是SC7731C X50142项目source后添加的环境变量:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ANDROID_DEV_SCRIPTS=/home/liujunhong/develop/X50142/idh.code/development/scripts:/home/liujunhong/develop/X50142/idh.code/prebuilts/devtools/tools:/home/liujunhong/develop/X50142/idh.code/external/selinux/prebuilts/bin</span><br><span class="line">ARM_EABI_TOOLCHAIN=/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin</span><br><span class="line">ANDROID_PRE_BUILD_PATHS=/usr/lib/jvm/java-8-openjdk-amd64/bin:</span><br><span class="line">ANDROID_BUILD_TOP=/home/liujunhong/develop/X50142/idh.code</span><br><span class="line">ANDROID_PRODUCT_OUT=/home/liujunhong/develop/X50142/idh.code/out/target/product/sp7731c_1h10</span><br><span class="line">ANDROID_JAVA_TOOLCHAIN=/usr/lib/jvm/java-8-openjdk-amd64/bin</span><br><span class="line">OUT=/home/liujunhong/develop/X50142/idh.code/out/target/product/sp7731c_1h10</span><br><span class="line">TARGET_BUILD_VARIANT=userdebug</span><br><span class="line">ASAN_OPTIONS=detect_leaks=0</span><br><span class="line">BUILD_ENV_SEQUENCE_NUMBER=10</span><br><span class="line">ANDROID_BUILD_PATHS=/home/liujunhong/develop/X50142/idh.code/out/host/linux-x86/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin::/home/liujunhong/develop/X50142/idh.code/development/scripts:/home/liujunhong/develop/X50142/idh.code/prebuilts/devtools/tools:/home/liujunhong/develop/X50142/idh.code/external/selinux/prebuilts/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/android-emulator/linux-x86_64:</span><br><span class="line">TARGET_BUILD_APPS=</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">PATH=/usr/lib/jvm/java-8-openjdk-amd64/bin:/home/liujunhong/develop/X50142/idh.code/out/host/linux-x86/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/:/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin::/home/liujunhong/develop/X50142/idh.code/development/scripts:/home/liujunhong/develop/X50142/idh.code/prebuilts/devtools/tools:/home/liujunhong/develop/X50142/idh.code/external/selinux/prebuilts/bin:/home/liujunhong/develop/X50142/idh.code/prebuilts/android-emulator/linux-x86_64:/usr/lib/jvm/java-8-openjdk-amd64/bin/:/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/<span class="built_in">local</span>/games:/usr/app/node-v4.5.0-linux-x64/bin:/home/liujunhong/Mydoc/bin</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line">ANDROID_TOOLCHAIN=/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin</span><br><span class="line">ANDROID_TOOLCHAIN_2ND_ARCH=/home/liujunhong/develop/X50142/idh.code/prebuilts/gcc/linux-x86/</span><br><span class="line">GCC_COLORS=error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01</span><br><span class="line">PYTHONPATH=/home/liujunhong/develop/X50142/idh.code/development/python-packages:</span><br><span class="line">ANDROID_EMULATOR_PREBUILTS=/home/liujunhong/develop/X50142/idh.code/prebuilts/android-emulator/linux-x86_64</span><br><span class="line">TARGET_GCC_VERSION=4.9</span><br><span class="line">ANDROID_HOST_OUT=/home/liujunhong/develop/X50142/idh.code/out/host/linux-x86</span><br><span class="line">TARGET_PRODUCT=sp7731c_1h10_oversea</span><br></pre></td></tr></table></figure></p>
<h3 id="2-lunch"><a href="#2-lunch" class="headerlink" title="2. lunch"></a>2. lunch</h3><p>lunch命令用于指定此次编译的目标产品，以下是7731c平台lunch时的输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">You&apos;re building on Linux</span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng</span><br><span class="line">     2. aosp_arm64-eng</span><br><span class="line">     ...</span><br><span class="line">     28. sp7731c_1h10_native-userdebug</span><br><span class="line">     29. sp7731c_1h10_native_trusty-userdebug</span><br><span class="line">     30. sp7731c_1h10_multi-userdebug</span><br><span class="line">     31. sp7731c_1h10_telcel-userdebug</span><br><span class="line">     32. sp7731c_1h10_vodafne-userdebug</span><br><span class="line">     33. sp7731c_1h10_claro-userdebug</span><br><span class="line">     34. sp7731c_1h10_orange-userdebug</span><br><span class="line">     35. sp7731c_1h10_oversea-userdebug</span><br><span class="line">     ...</span><br><span class="line">     46. sp8730se_1h10_qhd_native-userdebug</span><br><span class="line">...</span><br><span class="line">     49. sp8730se_1h10_qhd_native-userdebug</span><br></pre></td></tr></table></figure></p>
<p>这些配置是从哪里获取到的呢？我们就不得不说<code>add_lunch_combo</code>，如上文所说，<code>add_lunch_combo</code>升级是为lunch添加一个条目，而实际就是增加了一种<code>产品配置</code>   </p>
<p>在哪里有调用呢？ </p>
<ul>
<li><code>device/&lt;vendor&gt;/&lt;platform&gt;/&lt;board&gt;/vendorsetup.sh</code>，以下是我们SC7731C平台的代码文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">idh.code\device\sprd\scx20\sp7731c_1h10\vendorsetup.sh  </span><br><span class="line">add_lunch_combo sp7731c_1h10_native-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_native_trusty-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_multi-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_telcel-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_vodafne-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_claro-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_orange-userdebug</span><br><span class="line">add_lunch_combo sp7731c_1h10_oversea-userdebug</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们看看<code>add_lunch_combo</code>和<code>lunch</code>的代码可以知道,<code>add_lunch_combo</code>会将后面的参数去重后放到一个数组中<br>而<code>lunch</code>时只是先显示该数组的内容,然后根据用户的选择来设置并显示了一些环境变量然后显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add_lunch_combo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> new_combo=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> c</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="variable">$&#123;LUNCH_MENU_CHOICES[@]&#125;</span> ; <span class="keyword">do</span>  </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$new_combo</span>"</span> = <span class="string">"<span class="variable">$c</span>"</span> ] ; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    LUNCH_MENU_CHOICES=(<span class="variable">$&#123;LUNCH_MENU_CHOICES[@]&#125;</span> <span class="variable">$new_combo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lunch()</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">        print_lunch_menu</span><br><span class="line">        &lt;CODE FOR PARSE USER CHOOSE&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> TARGET_PRODUCT=<span class="variable">$product</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_VARIANT=<span class="variable">$variant</span></span><br><span class="line">    <span class="built_in">export</span> TARGET_BUILD_TYPE=release</span><br><span class="line">...</span><br><span class="line">    set_stuff_for_environment</span><br><span class="line">    printconfig</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那编译系统是在什么时候去读取的<code>vendorsetup.sh</code>文件呢? </p>
<ul>
<li>在<code>envsetup.sh</code>的最后,脚本会变量device目录,找到所有的<code>vendorsetup.sh</code>文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$SHELL</span>"</span> != <span class="string">"x/bin/bash"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">case</span> `ps -o <span class="built_in">command</span> -p $$` <span class="keyword">in</span></span><br><span class="line">        *bash*)</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"WARNING: Only bash is supported, use of other shell would lead to erroneous results"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute the contents of any vendorsetup.sh files we can find.</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> `<span class="built_in">test</span> -d device &amp;&amp; find -L device -maxdepth 4 -name <span class="string">'vendorsetup.sh'</span> 2&gt; /dev/null | sort` \</span><br><span class="line">         `<span class="built_in">test</span> -d vendor &amp;&amp; find -L vendor -maxdepth 4 -name <span class="string">'vendorsetup.sh'</span> 2&gt; /dev/null | sort` \</span><br><span class="line">         `<span class="built_in">test</span> -d product &amp;&amp; find -L product -maxdepth 4 -name <span class="string">'vendorsetup.sh'</span> 2&gt; /dev/null | sort`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"including <span class="variable">$f</span>"</span></span><br><span class="line">    . <span class="variable">$f</span> <span class="comment">#运行找到的脚本(注意是用". "来运行的,相当与source vendorsetup.sh)</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">unset</span> f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为我们在<code>add_lunch_combo</code>的时候默认的<code>varient</code>是<code>userdebug</code>,如果我们需要编译其他类型的版本,我们还需要使用<code>choosevariant</code>来选择我们需要编译的版本类型<br>variant通常有三种:   </p>
<ul>
<li>user:代表这是编译出的系统镜像是可以用来正式发布到市场的版本,其权限是被限制的(如没有root权限等)</li>
<li>userdebug:在user版本的基础上开放了root权限和debug权限.</li>
<li>eng:代表engineer,也就是所谓的开发工程师的版本,拥有最大的权限(root等),此外还附带了许多debug工具</li>
</ul>
<h3 id="3-make"><a href="#3-make" class="headerlink" title="3. make"></a>3. make</h3><h4 id="3-1-编译目标"><a href="#3-1-编译目标" class="headerlink" title="3.1 编译目标"></a>3.1 编译目标</h4><p>当我们在Android源码根目录下执行make的时候，会查找当前目录下的Makefie文件或者makefile文件并且执行，在android/Makefile文件中，它只有一行有用的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### DO NOT EDIT THIS FILE ###</span><br><span class="line">include build/core/main.mk</span><br><span class="line">### DO NOT EDIT THIS FILE ###</span><br></pre></td></tr></table></figure></p>
<p>因此，执行make时真正的入口是android/build/core/main.mk文件<br>我们在Android源码根目录下执行make命令的时候，并没有传入目标，那么就会执行默认的目标。那默认的目标是什么呢？在android/build/core/main.mk中有这样几行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># This is the default target.  It must be the first declared target.</span><br><span class="line">.PHONY: droid</span><br><span class="line">DEFAULT_GOAL := droid</span><br><span class="line">$(DEFAULT_GOAL): droid_targets</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Building a full system-- the default is to build droidcore</span><br><span class="line">droid_targets: droidcore dist_files</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Build files and then package it into the rom formats</span><br><span class="line">.PHONY: droidcore</span><br><span class="line">droidcore: files \</span><br><span class="line">	systemimage \</span><br><span class="line">	$(INSTALLED_BOOTIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_RECOVERYIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_USERDATAIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_CACHEIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_PRODNVIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_VENDORIMAGE_TARGET) \</span><br><span class="line">	$(INSTALLED_FILES_FILE) \</span><br><span class="line">	$(INSTALLED_FILES_FILE_VENDOR)</span><br></pre></td></tr></table></figure>
<p>可以看到默认的目标是<code>droid</code>,而<code>droid</code>又依赖<code>droid_targets</code>,<code>droid_targets</code>又依赖<code>droidcore</code> 和 <code>dist_files</code>,然后<code>droidcore</code>依赖的就是各类images</p>
<p><img src="&quot;图片来源:http://blog.csdn.net/lizekun2010/article/details/52598105&quot;" alt="targets.png"></p>
<h4 id="3-2-其他-Make-命令"><a href="#3-2-其他-Make-命令" class="headerlink" title="3.2 其他 Make 命令"></a>3.2 其他 Make 命令</h4><table>
<thead>
<tr>
<th>Make 目标</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>make clean</td>
<td>执行清理，等同于：rm -rf out/。</td>
</tr>
<tr>
<td>make sdk</td>
<td>编译出 Android 的 SDK。</td>
</tr>
<tr>
<td>make clean-sdk</td>
<td>清理 SDK 的编译产物。</td>
</tr>
<tr>
<td>make update-api</td>
<td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的 API 记录在 frameworks/base/api 目录下。</td>
</tr>
<tr>
<td>make dist</td>
<td>执行 Build，并将 MAKECMDGOALS 变量定义的输出文件拷贝到 /out/dist 目录。</td>
</tr>
<tr>
<td>make all</td>
<td>编译所有内容，不管当前产品的定义中是否会包含。</td>
</tr>
<tr>
<td>make help</td>
<td>帮助信息，显示主要的 make 目标。</td>
</tr>
<tr>
<td>make snod</td>
<td>从已经编译出的包快速重建系统镜像。（其实主要对system进行打包）</td>
</tr>
<tr>
<td></td>
<td>make snod  — system.i</td>
</tr>
<tr>
<td>make libandroid_runtime</td>
<td>编译所有 JNI framework 内容。</td>
</tr>
<tr>
<td>make framework</td>
<td>编译所有 Java framework 内容。</td>
</tr>
<tr>
<td>make services</td>
<td>编译系统服务和相关内容。</td>
</tr>
<tr>
<td>make <local_target></local_target></td>
<td>编译一个指定的模块，local_target 为模块的名称。</td>
</tr>
<tr>
<td>make clean-<local_target></local_target></td>
<td>清理一个指定模块的编译结果。</td>
</tr>
<tr>
<td>make dump-products</td>
<td>显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</td>
</tr>
<tr>
<td>make bootimage</td>
<td>生成 boot.img</td>
</tr>
<tr>
<td>make recoveryimage</td>
<td>生成 recovery.img</td>
</tr>
<tr>
<td>make userdataimage</td>
<td>生成 userdata.img</td>
</tr>
<tr>
<td>make cacheimage</td>
<td>生成 cache.img</td>
</tr>
</tbody>
</table>
<h2 id="3-2-编译流程"><a href="#3-2-编译流程" class="headerlink" title="3.2 编译流程"></a>3.2 编译流程</h2><blockquote>
<p>main.mk –&gt; config.mk –&gt; envsetup.mk –&gt; product_config.mk      </p>
</blockquote>
<p>下面就来看看<code>product_config.mk</code>文件，首先调用方法get-all-product-makefiles找出所有的AndoridProducts.mk文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifneq ($(strip $(TARGET_BUILD_APPS)),)</span><br><span class="line"># An unbundled app build needs only the core product makefiles.</span><br><span class="line">all_product_configs := $(call get-product-makefiles,\</span><br><span class="line">    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)</span><br><span class="line">else</span><br><span class="line"># Read in all of the product definitions specified by the AndroidProducts.mk</span><br><span class="line"># files in the tree.</span><br><span class="line">all_product_configs := $(get-all-product-makefiles)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>然后从all_product_configs中找出我们当前产品的all_product_makefiles文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Find the product config makefile for the current product.</span><br><span class="line"># all_product_configs consists items like:</span><br><span class="line"># &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt;</span><br><span class="line"># or just &lt;path_to_the_product_makefile&gt; in case the product name is the</span><br><span class="line"># same as the base filename of the product config makefile.</span><br><span class="line">current_product_makefile :=</span><br><span class="line">all_product_makefiles :=</span><br><span class="line">$(foreach f, $(all_product_configs),\</span><br><span class="line">    $(eval _cpm_words := $(subst :,$(space),$(f)))\</span><br><span class="line">    $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\</span><br><span class="line">    $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\</span><br><span class="line">    $(if $(_cpm_word2),\</span><br><span class="line">        $(eval all_product_makefiles += $(_cpm_word2))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\</span><br><span class="line">            $(eval current_product_makefile += $(_cpm_word2)),),\</span><br><span class="line">        $(eval all_product_makefiles += $(f))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\</span><br><span class="line">            $(eval current_product_makefile += $(f)),)))</span><br><span class="line">_cpm_words :=</span><br><span class="line">_cpm_word1 :=</span><br><span class="line">_cpm_word2 :=</span><br><span class="line">current_product_makefile := $(strip $(current_product_makefile))</span><br></pre></td></tr></table></figure></p>
<p>比如我们在执行lunch时选择的是sp7731c_1h10_oversea，则current_product_makefile的值就是：device/sprd/scx20/sp7731c_1h10/sp7731c_1h10_oversea.mk<br>接着调用import-products导入产品配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call import-products, $(current_product_makefile))</span><br></pre></td></tr></table></figure></p>
<p>接着设置TARGET_DEVICE的值，其实就是sp7731c_1h10：<br>TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE)<br>接着设置PRODUCT_COPY_FILES，这个变量指定了需要拷贝的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES := \  </span><br><span class="line">    $(strip $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_COPY_FILES))</span><br></pre></td></tr></table></figure></p>
<p>接着设置PRODUCT_PROPERTY_OVERRIDES属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_PROPERTY_OVERRIDES := \  </span><br><span class="line">    $(strip $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PROPERTY_OVERRIDES))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">board_config_mk := \</span><br><span class="line">        $(strip $(sort $(wildcard \</span><br><span class="line">                $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \</span><br><span class="line">                $(shell test -d device &amp;&amp; find -L device -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \</span><br><span class="line">                $(shell test -d vendor &amp;&amp; find -L vendor -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \</span><br><span class="line">        )))</span><br><span class="line">ifeq ($(board_config_mk),)</span><br><span class="line">  $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE))</span><br><span class="line">endif</span><br><span class="line">ifneq ($(words $(board_config_mk)),1)</span><br><span class="line">  $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk))</span><br><span class="line">endif</span><br><span class="line">include $(board_config_mk)</span><br></pre></td></tr></table></figure>
<p>至此，板型配置基本加载完毕。开始加载所有模块<br>加载完板型配置信息后，回到main.mk文件中，很快发现了ONE_SHOT_MAKEFILE的使用。如果这个变量被定义了，那么就是编译一个模块，如果没有被定义，就说明是编译整个系统。MAKECMDGOALS是make的一个环境变量，当我们执行make的时候并没有设置它，因此它为空。所以dont_bother不等于true，因此会加载所有的Android.mk，这里是调用一个Python脚本android/build/tools/findleaves.py来查找系统中所有的Android.mk，然后循环include进来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Include all of the makefiles in the system  </span><br><span class="line"># </span><br><span class="line"># Can&apos;t use first-makefiles-under here because  </span><br><span class="line"># --mindepth=2 makes the prunes not work.  </span><br><span class="line">subdir_makefiles := \  </span><br><span class="line">    $(shell build/tools/findleaves.py $(FIND_LEAVES_EXCLUDES) $(subdirs) Android.mk)  </span><br><span class="line"></span><br><span class="line">ifeq ($(USE_SOONG),true)  </span><br><span class="line">subdir_makefiles := $(SOONG_ANDROID_MK) $(call filter-soong-makefiles,$(subdir_makefiles))  </span><br><span class="line">endif  </span><br><span class="line">$(foreach mk, $(subdir_makefiles),$(info including $(mk) ...)$(eval include $(mk)))</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了,我们要加一个新的<code>产品配置</code>要改什么文件呢?</p>
<h2 id="添加新的产品"><a href="#添加新的产品" class="headerlink" title="添加新的产品"></a>添加新的产品</h2><p>当要开发一款新的 Android 产品的时候，我们首先需要在 Build 系统中添加对于该产品的定义。<br>在 Android Build 系统中对产品定义的文件通常位于 device 目录下。device 目录下根据公司名以及产品名分为二级或多级目录。<br>通常，对于一个产品的定义通常至少会包括四个文件：AndroidProducts.mk，产品版本定义文件，BoardConfig.mk 以及 verndorsetup.sh。</p>
<ul>
<li><p>/device/sprd/scx20/sp7731c_4h10/vendorsetup.sh:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_lunch_combo sp7731c_4h10_native-userdebug</span><br></pre></td></tr></table></figure>
</li>
<li><p>/device/sprd/scx20/sp7731c_4h10/AndroidProducts.mk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_MAKEFILES := \</span><br><span class="line">    $(LOCAL_DIR)/sp7731c_4h10_native.mk</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>产品版本定义文件：顾名思义，该文件中包含了对于特定产品版本的定义。该文件可能不只一个，因为同一个产品可能会有多种版本（例如，面向中国地区一个版本，面向美国地区一个版本）。<br>文件中可以定义的变量以及含义</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PRODUCT_NAME</td>
<td>最终用户将看到的完整产品名，会出现在“关于手机”信息中。</td>
</tr>
<tr>
<td>PRODUCT_MODEL</td>
<td>产品的型号，这也是最终用户将看到的。</td>
</tr>
<tr>
<td>PRODUCT_LOCALES</td>
<td>该产品支持的地区，以空格分格，例如：en_GB de_DE es_ES fr_CA。</td>
</tr>
<tr>
<td>PRODUCT_PACKAGES</td>
<td>该产品版本中包含的 APK 应用程序，以空格分格，例如：Calendar Contacts。</td>
</tr>
<tr>
<td>PRODUCT_DEVICE</td>
<td>该产品的工业设计的名称。</td>
</tr>
<tr>
<td>PRODUCT_MANUFACTURER</td>
<td>制造商的名称。</td>
</tr>
<tr>
<td>PRODUCT_BRAND</td>
<td>该产品专门定义的商标（如果有的话）。</td>
</tr>
<tr>
<td>PRODUCT_PROPERTY_OVERRIDES</td>
<td>对于商品属性的定义。</td>
</tr>
<tr>
<td>PRODUCT_COPY_FILES</td>
<td>编译该产品时需要拷贝的文件，以“源路径 : 目标路径”的形式。</td>
</tr>
<tr>
<td>PRODUCT_OTA_PUBLIC_KEYS</td>
<td>对于该产品的 OTA 公开 key 的列表。</td>
</tr>
<tr>
<td>PRODUCT_POLICY</td>
<td>产品使用的策略。</td>
</tr>
<tr>
<td>PRODUCT_PACKAGE_OVERLAYS</td>
<td>指出是否要使用默认的资源或添加产品特定定义来覆盖。</td>
</tr>
<tr>
<td>PRODUCT_CONTRIBUTORS_FILE</td>
<td>HTML 文件，其中包含项目的贡献者。</td>
</tr>
<tr>
<td>PRODUCT_TAGS</td>
<td>该产品的标签，以空格分格。</td>
</tr>
</tbody>
</table>
<h2 id="添加新的模块"><a href="#添加新的模块" class="headerlink" title="添加新的模块"></a>添加新的模块</h2><p>在源码树中，一个模块的所有文件通常都位于同一个文件夹中。为了将当前模块添加到整个 Build 系统中，每个模块都需要一个专门的 Make 文件，该文件的名称为“Android.mk”。Build 系统会扫描名称为“Android.mk”的文件，并根据该文件中内容编译出相应的产物。</p>
<p>需要注意的是：在 Android Build 系统中，编译是以模块（而不是文件）作为单位的，每个模块都有一个唯一的名称，一个模块的依赖对象只能是另外一个模块，而不能是其他类型的对象。对于已经编译好的二进制库，如果要用来被当作是依赖对象，那么应当将这些已经编译好的库作为单独的模块。对于这些已经编译好的库使用 <code>BUILD_PREBUILT</code> 或 <code>BUILD_MULTI_PREBUILT</code>。例如：当编译某个 Java 库需要依赖一些 Jar 包时，并不能直接指定 Jar 包的路径作为依赖，而必须首先将这些 Jar 包定义为一个模块，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。</p>
<h3 id="Android-mk-解析"><a href="#Android-mk-解析" class="headerlink" title="Android.mk 解析"></a>Android.mk 解析</h3><p>在源码树中每一个模块的所有文件通常都相应有一个自己的文件夹，在该模块的根目录下有一个名称为“Android.mk” 的文件。编译系统正是以模块为单位进行编译，每个模块都有唯一的模块名，一个模块可以有依赖多个其他模块，模块间的依赖关系就是通过模块名来引用的。也就是说当模块需要依赖一个jar包或者apk时，必须先将jar包或apk定义为一个模块，然后再依赖相应的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir) </span><br><span class="line">include $(CLEAR_VARS)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两行代码的作用是：<br>设置当前模块的编译路径为当前文件夹路径。<br>清理（可能由其他模块设置过的）编译环境中用到的变量。   </p>
</blockquote>
<p>为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOCAL_SRC_FILES</td>
<td>当前模块包含的所有源代码文件。</td>
</tr>
<tr>
<td>LOCAL_MODULE</td>
<td>当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。</td>
</tr>
<tr>
<td>LOCAL_C_INCLUDES</td>
<td>C 或 C++ 语言需要的头文件的路径。LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。</td>
</tr>
<tr>
<td>LOCAL_CFLAGS</td>
<td>提供给 C/C++ 编译器的额外编译参数。</td>
</tr>
<tr>
<td>LOCAL_JAVA_LIBRARIES</td>
<td>当前模块依赖的 Java 共享库。</td>
</tr>
<tr>
<td>LOCAL_STATIC_JAVA_LIBRARIES</td>
<td>前模块依赖的 Java 静态库。LOCAL_PACKAGE_NAME：当前 APK 应用的名称。</td>
</tr>
<tr>
<td>LOCAL_CERTIFICATE</td>
<td>签署当前应用的证书名称。</td>
</tr>
<tr>
<td>LOCAL_MODULE_TAGS</td>
<td>当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 debug, eng, user，development 或者 optional(默认)。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>标签是提供给编译类型使用的。不同的编译类型会安装包含不同标签的模块。<br>要编译一个 APK 文件，只需要在 Android.mk 文件中，加入“include $(BUILD_PACKAGE)   </p>
</blockquote>
<p>除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(call my-dir)</td>
<td>获取当前文件夹路径。</td>
</tr>
<tr>
<td>$(call all-java-files-under, <src>)</src></td>
<td>获取指定目录下的所有 Java 文件。</td>
</tr>
<tr>
<td>$(call all-c-files-under, <src>)</src></td>
<td>获取指定目录下的所有 C 语言文件。</td>
</tr>
<tr>
<td>$(call all-Iaidl-files-under, <src>)</src></td>
<td>获取指定目录下的所有 AIDL 文件。</td>
</tr>
<tr>
<td>$(call all-makefiles-under, <folder>)</folder></td>
<td>获取指定目录下的所有 Make 文件。</td>
</tr>
<tr>
<td>$(call intermediates-dir-for, <class>, <app_name>, <host or="" target="">, <common?> )</common?></host></app_name></class></td>
<td>获取 Build 输出的目标文件夹路径。</td>
</tr>
</tbody>
</table>
<p>示例:</p>
<ul>
<li><p>编译一个 APK 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir) </span><br><span class="line">include $(CLEAR_VARS) </span><br><span class="line"># 获取所有子目录中的 Java 文件</span><br><span class="line">LOCAL_SRC_FILES := $(call all-subdir-java-files)             </span><br><span class="line"># 当前模块依赖的静态 Java 库，如果有多个以空格分隔</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := static-library </span><br><span class="line"># 当前模块的名称</span><br><span class="line">LOCAL_PACKAGE_NAME := LocalPackage </span><br><span class="line"># 编译 APK 文件</span><br><span class="line">include $(BUILD_PACKAGE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译一个 Java 的静态库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir) </span><br><span class="line">include $(CLEAR_VARS) </span><br><span class="line"></span><br><span class="line"># 获取所有子目录中的 Java 文件</span><br><span class="line">LOCAL_SRC_FILES := $(call all-subdir-java-files) </span><br><span class="line"></span><br><span class="line"># 当前模块依赖的动态 Java 库名称</span><br><span class="line">LOCAL_JAVA_LIBRARIES := android.test.runner </span><br><span class="line"></span><br><span class="line"># 当前模块的名称</span><br><span class="line">LOCAL_MODULE := sample </span><br><span class="line"></span><br><span class="line"># 将当前模块编译成一个静态的 Java 库</span><br><span class="line">include $(BUILD_STATIC_JAVA_LIBRARY)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="SPROCOMM-Android项目编译脚本"><a href="#SPROCOMM-Android项目编译脚本" class="headerlink" title="SPROCOMM Android项目编译脚本"></a>SPROCOMM Android项目编译脚本</h1><p>介绍完Android原始的编译系统,我们再看看禾苗编译系统做了些什么,我们从<code>buildall_eng.sh</code>说起</p>
<ol>
<li><p>处理并检查脚本参数,最新版本的脚本支持如下参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"USAGE: <span class="variable">$0</span> &lt;PROJECT&gt; [ota] [pac] [copy] [boot] [bootloader] [recovery] [snod] [api] [env] [nodex] [-m &lt;MODULE&gt;]"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* OTA : 编译OTA包"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* BOOT : 编译boot.img"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* CHIPRAM : 编译chipram"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* RECOVERY : 编译recovery.img"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* BOOTLOADER : 编译bootloader(u-boot.bin)"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* SNOD : 打包system.img"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* -m &lt;MODULE&gt; : 编译&lt;MODULE&gt;指定的模块(-m bootloader)"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* PAC : 编译完成后自动打包(*.pac)"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* COPY : 拷贝覆盖文件，不启动编译"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* API : 提示需要更新api时加该参数:更新api.txt，编译完成后请将framework中的api文件提交到git上"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* ENV : 单编source时加该参数，只设置环境，不启动编译"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* NODEX : 全编DEBUG版本时不生成odex文件"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"* 参数不区分大小写和顺序"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为7.0平台设置Java环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaVersion=`<span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span> | grep <span class="string">"java-8-openjdk-amd64"</span>`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$javaVersion</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Set JAVA_HOME as /usr/lib/jvm/java-8-openjdk-amd64"</span></span><br><span class="line">    <span class="built_in">export</span> JAVA_HOME=<span class="string">"/usr/lib/jvm/java-8-openjdk-amd64"</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/jre/bin/:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin/:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>sprplus_target_gen.pl</code>解析项目对应的spec生成配置文件文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/buildplus/tool/sprplus_target_gen.pl  <span class="variable">$&#123;PROJECT&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">输出:</span></span><br><span class="line">build/buildplus/buildspec/X50142.spec</span><br><span class="line">Copy build/buildplus/target/Features.java to frameworks/base/core/java/android/plugin/</span><br><span class="line">Copy build/buildplus/target/spr_target.h to kernel/include/linux/</span><br><span class="line">Copy build/buildplus/target/spr_target.h to chipram/include/configs/</span><br><span class="line">Copy build/buildplus/target/spr_target.h to system/core/include/android/</span><br><span class="line">Copy build/buildplus/target/spr_target.h to u-boot64/include/configs/</span><br><span class="line">Copy build/buildplus/target/spr_target.h to kernel/scripts/</span><br></pre></td></tr></table></figure>
<ol>
<li><p>拷贝覆盖文件和编译ota时所需要的modem以及audio_para文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Copy overlay files ##</span></span><br><span class="line">OVERLAY_FILE=./sprocomm_proj/<span class="variable">$&#123;PROJECT&#125;</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$&#123;OVERLAY_FILE&#125;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    cp -rf <span class="variable">$&#123;OVERLAY_FILE&#125;</span>/* ./</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"WARNING!!! Overlay file Not found!"</span> ; sleep 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">modem_bins_dir=device/sprd/<span class="variable">$&#123;CONFIG_DEVICE_PLATFORM&#125;</span>/<span class="variable">$&#123;CONFIG_DEVICE_BOARD&#125;</span>/modem_bins</span><br><span class="line">audio_paras_dir=device/sprd/<span class="variable">$&#123;CONFIG_DEVICE_PLATFORM&#125;</span>/<span class="variable">$&#123;CONFIG_DEVICE_BOARD&#125;</span>/rootdir/system/etc/audio_params/audio_para</span><br><span class="line"></span><br><span class="line">modem_dir=modem/<span class="variable">$&#123;PROJECT&#125;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"default"</span> != <span class="variable">$&#123;BUILD_HARDWARE_CLASS&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">    modem_dir=modem/<span class="variable">$&#123;PROJECT&#125;</span>-<span class="variable">$&#123;BUILD_HARDWARE_CLASS&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$&#123;modem_dir&#125;</span>/audio_para ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"copy "</span><span class="variable">$&#123;modem_dir&#125;</span>/audio_para<span class="string">" to "</span><span class="variable">$&#123;audio_paras_dir&#125;</span></span><br><span class="line">    cp <span class="variable">$&#123;modem_dir&#125;</span>/audio_para <span class="variable">$&#123;audio_paras_dir&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$&#123;modem_bins_dir&#125;</span></span><br><span class="line">cp <span class="variable">$&#123;modem_dir&#125;</span>/DSP_DM_G2.bin  <span class="variable">$&#123;modem_bins_dir&#125;</span>/wdsp.bin</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"true"</span> = <span class="variable">$&#123;BUILD_COPY_ONLY&#125;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    [ <span class="variable">$BUILD_ENV</span> = <span class="string">"false"</span> ] &amp;&amp; <span class="built_in">exit</span> 1; <span class="built_in">return</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行Android原生的编译脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch <span class="variable">$&#123;CONFIG_DEVICE_PRODUCT&#125;</span>-userdebug</span><br><span class="line">choosevariant <span class="variable">$&#123;varient_val&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行展讯编译kernel额外的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kheader</span><br><span class="line">kdconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有必要则重启一次jack服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmArg=`<span class="built_in">echo</span> <span class="variable">$JACK_SERVER_VM_ARGUMENTS</span> | grep <span class="string">"Xmx4096m"</span>`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$vmArg</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> JACK_SERVER_VM_ARGUMENTS=<span class="string">"-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"restart jack server"</span></span><br><span class="line">    bash ./prebuilts/sdk/tools/jack-admin <span class="built_in">kill</span>-server </span><br><span class="line">    bash ./prebuilts/sdk/tools/jack-admin start-server</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝展讯7.0平台提供的proprietories文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Copy SPRD7.0 proprietories files</span></span><br><span class="line">PROPRIETORIES=<span class="string">"vendor/sprd/proprietories-out/<span class="variable">$&#123;CONFIG_DEVICE_PRODUCT&#125;</span>-<span class="variable">$&#123;BUILD_VARIANT&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$PROPRIETORIES</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PROPRIETORIES</span> not exists, using native file...</span><br><span class="line">sleep 3</span><br><span class="line">PROPRIETORIES=<span class="string">"vendor/sprd/proprietories-out/<span class="variable">$&#123;CONFIG_DEVICE_BOARD&#125;</span>_native-<span class="variable">$&#123;BUILD_VARIANT&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> Copy <span class="variable">$PROPRIETORIES</span> to out</span><br><span class="line">cp -rf <span class="variable">$PROPRIETORIES</span>/* .</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始编译</p>
<blockquote>
<p><code>BUILD_MODULE_CMD</code> 可能会指定一些别的模块,这样就会编译指定的模块,而不是整个android系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MULTILANGUAGE_SUPPORT=<span class="literal">true</span> DEBUG_WITH_DEXPREOPT=<span class="variable">$&#123;DEBUG_WITH_DEXPREOPT&#125;</span> make <span class="variable">$&#123;BUILD_MODULE_CMD&#125;</span> -j<span class="variable">$JN</span> 2&gt;&amp;1 | tee <span class="variable">$&#123;SAVE_PATH&#125;</span>/build.log</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果有必要,则编译并打包ota包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build otapackage#</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"true"</span> = <span class="variable">$&#123;BUILD_OTA&#125;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    MULTILANGUAGE_SUPPORT=<span class="literal">true</span> DEBUG_WITH_DEXPREOPT=<span class="variable">$&#123;DEBUG_WITH_DEXPREOPT&#125;</span> make otapackage -j<span class="variable">$JN</span> 2&gt;&amp;1 | tee <span class="variable">$&#123;SAVE_PATH&#125;</span>/buildOta.log</span><br><span class="line">    RESULT=<span class="variable">$&#123;PIPESTATUS[0]&#125;</span> ; <span class="keyword">if</span> [ ! <span class="string">"0"</span> = <span class="variable">$&#123;RESULT&#125;</span> ] ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"Build Abort!"</span>; [ <span class="variable">$BUILD_ENV</span> = <span class="string">"false"</span> ] &amp;&amp; <span class="built_in">exit</span> 1; <span class="built_in">return</span>; <span class="keyword">fi</span></span><br><span class="line">    <span class="comment">#cp -f $&#123;BUILD_OUT_DIR&#125;/*-ota-*.zip $&#123;SAVE_PATH&#125;</span></span><br><span class="line">    cp -f <span class="variable">$&#123;BUILD_OUT_DIR&#125;</span>/*-fota-Package.zip <span class="variable">$&#123;SAVE_PATH&#125;</span></span><br><span class="line">    </span><br><span class="line">    RESULT=$? ; <span class="keyword">if</span> [ ! <span class="string">"0"</span> = <span class="variable">$&#123;RESULT&#125;</span> ] ; <span class="keyword">then</span> </span><br><span class="line">        cp -f <span class="variable">$&#123;BUILD_OUT_DIR&#125;</span>/obj/PACKAGING/target_files_intermediates/*target_files*.zip <span class="variable">$&#123;SAVE_PATH&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有必要则打包生成的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Start Pack ##</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"true"</span> = <span class="variable">$&#123;BUILD_PAC&#125;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    cp -f <span class="variable">$&#123;BUILD_OUT_DIR&#125;</span>/system/build.prop <span class="variable">$&#123;SAVE_PATH&#125;</span></span><br><span class="line">    cp -f <span class="variable">$&#123;BUILD_OUT_DIR&#125;</span>/obj/KERNEL/vmlinux <span class="variable">$&#123;SAVE_PATH&#125;</span></span><br><span class="line">    <span class="keyword">if</span> [ ! <span class="string">"user"</span> = <span class="variable">$&#123;BUILD_VARIANT&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">        zip -r <span class="variable">$&#123;SAVE_PATH&#125;</span>_ENG.zip <span class="variable">$&#123;SAVE_PATH&#125;</span>/*</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        zip -r <span class="variable">$&#123;SAVE_PATH&#125;</span>.zip <span class="variable">$&#123;SAVE_PATH&#125;</span>/*</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    rm <span class="variable">$&#123;SAVE_PATH&#125;</span> -rf;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"default"</span> != <span class="variable">$&#123;BUILD_HARDWARE_CLASS&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">        ./make_pac.sh <span class="variable">$&#123;PROJECT&#125;</span> <span class="variable">$&#123;BUILD_HARDWARE_CLASS&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ./make_pac.sh <span class="variable">$&#123;PROJECT&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此是编译的全部流程,其中有几点需要我们注意:   </p>
<h2 id="SPEC文件的规则"><a href="#SPEC文件的规则" class="headerlink" title="SPEC文件的规则"></a>SPEC文件的规则</h2><p>Android 7.0平台上我重写了SPEC文件的规则和解析脚本,规则如下</p>
<ol>
<li>每个项目都应该有一个与项目名相同的spec文件,如<code>build/buildplus/buildspec/X50142.spec</code></li>
<li>spec 文件使用分号(“;”)标识注释, 并要求行尾不要有windows换行符”\r”(7.0引入jack,该符号会导致编译报错)</li>
<li>将所有的变量整理在一起，去掉不需要的变量，并规范变量名   </li>
<li>变量规则，所有定义的变量都按照KEY\<type\>=VALUE的格式书写，其中TYPE支持如下几种：   <blockquote>
<pre><code>* BUILD : Makefile 变量   
* String：Java变量   
* int : Java 变量   
* boolean： Java变量   
* Native ： C/C++  常量   
* DEFINE:  C/C++ 宏 （value=1 时生成#define KEY， 否则生成#define KEY_UNDEFINED）   
</code></pre></blockquote>
</type\></li>
<li>添加一个新的变量时需要先在<code>build\buildplus\namespace\names.ini</code>配置其默认值(如果xxx.spec中未定义,则生成的文件中变量的值未name.ini中定义的默认值),否则添加的变量不能反应到输出的文件中</li>
<li>去除6.0中的如下属性ro.project.customer_name、ro.project.customer_sku、ro.project.name（原因: 衍生项目有可能被用户看到别的客户名，有些代码将getprop放在循环中引发性能问题）所有Java中判断属性通过如下常量获取<blockquote>
<pre><code>* android.os.Build.CUSTOMER ： 客户名   
* android.os.Build.CUSTOMER_SKU ： 客户品牌名（Lava/Xolo）   
* android.os.Build.PROJECT ： 项目名   
</code></pre></blockquote>
</li>
<li>针对之前项目与device目录对应关系不清楚问题，将以前的CONFIG_DEVICE_BOARD  = scx20、CONFIG_DEVICE_PRODUCT  = sp7731c_1h10修改为3个宏，创建项目时请注意：<blockquote>
<pre><code>* CONFIG_DEVICE_PLATFORM\&lt;BUILD\&gt;  = scx20   
* CONFIG_DEVICE_BOARD\&lt;BUILD\&gt;  = sp7731c_1h10   
* CONFIG_DEVICE_PRODUCT\&lt;BUILD\&gt;  = sp7731c_1h10_oversea   
</code></pre></blockquote>
</li>
<li>BUILD类型的变量的值不允许添加引号</li>
</ol>
<h2 id="SPEC文件的解析"><a href="#SPEC文件的解析" class="headerlink" title="SPEC文件的解析"></a>SPEC文件的解析</h2><ol>
<li>SPEC文件使用<code>sprplus_target_gen.pl</code>脚本解析,并在<code>build\buildplus\target</code>目录下生成3个文件<blockquote>
<ul>
<li>Features.java</li>
<li>spr_target.h</li>
<li>spr_target.min<br>分别供java, c/c++, 以及makefile使用<br>其中<code>spr_target.h</code>还会被copy到”kernel”, “chipram”, “uboot”, “system”代码的include文件夹中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my $targetDefaultNativePath = <span class="string">"build/buildplus/target/spr_target.h"</span>;</span><br><span class="line">my @targetNativePaths =  (<span class="string">"kernel/include/linux/"</span>,</span><br><span class="line">                    <span class="string">"chipram/include/configs/"</span>,</span><br><span class="line">                    <span class="string">"system/core/include/android/"</span>,</span><br><span class="line">                    <span class="string">"u-boot64/include/configs/"</span>,</span><br><span class="line">                    <span class="string">"kernel/scripts/"</span>,);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="关于覆盖目录"><a href="#关于覆盖目录" class="headerlink" title="关于覆盖目录"></a>关于覆盖目录</h2><p>由于驱动中的部分文件不方便作项目区分,保留了覆盖目录,覆盖目录位于./sprocomm_proj/${PROJECT},在编译或者source单编的时候会被拷贝覆盖到原始的代码中.<br>因为滥用覆盖目录会经常会导致代码被误提交,修改不生效,升级大版本复杂等问题, 请尽量避免使用覆盖的方式区分项目和代码, 同时脚本中也做了限制,禁止如下几种类型添加到覆盖目录中,当在覆盖目录中创建这几类文件时会提示错误</p>
<blockquote>
<ul>
<li>.java</li>
<li>.cpp</li>
<li>.cc</li>
<li>.mk</li>
<li>.sh</li>
<li>.py</li>
<li>.pl<br>如果无论如何都要覆盖这几个文件,此时可以删除.git/hooks/pre-commit再重新commit(pre-commit文件会在重新编译后再次生成)</li>
</ul>
</blockquote>
<ul>
<li>关于各类文件区分项目,可以参考如下修改<br><a href="http://192.168.11.104/gitweb/?p=MOCORDROID7.0_Trunk_K310_17A_W17.04.2.git;a=commitdiff;h=77a7000d049c44a3e5cc35fa985f7949f8b4c9ed;hp=fefbe6f615f18e2153ac7f9d35db9ca4f97778fc" target="_blank" rel="noopener">参考代码</a></li>
</ul>
<ol>
<li>java文件,先在spec中定义变量(JAVA_VALUE_WIFI_HOT_SSID):<blockquote>
<p>JAVA_VALUE_WIFI_HOT_SSID\<string\> = “alcatel U5”;</string\></p>
</blockquote>
</li>
</ol>
<p>再修改代码引用:<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      */</span><br><span class="line">     private WifiConfiguration getDefaultApConfiguration() &#123;</span><br><span class="line">         WifiConfiguration config = new WifiConfiguration();</span><br><span class="line"><span class="deletion">-        config.SSID = mContext.getResources().getString(</span></span><br><span class="line"><span class="deletion">-                R.string.wifi_tether_configure_ssid_default);</span></span><br><span class="line"><span class="addition">+        //SPROCOMM</span></span><br><span class="line"><span class="addition">+        //config.SSID = mContext.getResources().getString(</span></span><br><span class="line"><span class="addition">+        //        R.string.wifi_tether_configure_ssid_default);</span></span><br><span class="line"><span class="addition">+        config.SSID = android.plugin.Features.JAVA_VALUE_WIFI_HOT_SSID;</span></span><br><span class="line">         config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>makfile文件,同样定义变量:<blockquote>
<p>MODULES_PROJECT_NAME\<build\> = X50142   </build\></p>
</blockquote>
</li>
</ol>
<p>再修改引用代码:<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/idh.code/device/sprd/scx20/sp7731c_1h10/BoardConfig.mk</span></span><br><span class="line"><span class="comment">+++ b/idh.code/device/sprd/scx20/sp7731c_1h10/BoardConfig.mk</span></span><br><span class="line">@@ -146,3 +146,14 @@ DEVICE_GSP_NOT_SCALING_UP_TWICE := true</span><br><span class="line"> </span><br><span class="line"> #UCAM feature</span><br><span class="line"> TARGET_BOARD_CAMERA_FACE_BEAUTY := true # hal config</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+include build/buildplus/target/spr_target.min</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ifeq ($(MODULES_PROJECT_NAME), X50142)</span></span><br><span class="line"><span class="addition">+CAMERA_SENSOR_TYPE_BACK := "ov5005_mipi_raw"</span></span><br><span class="line"><span class="addition">+CAMERA_SENSOR_TYPE_FRONT := "gc030a_mipi_raw"</span></span><br><span class="line"><span class="addition">+BOARD_HAVE_ACC := BMA2X2</span></span><br><span class="line"><span class="addition">+BOARD_ACC_INSTALL := 0</span></span><br><span class="line"><span class="addition">+BOARD_HAVE_PLS := TP</span></span><br><span class="line"><span class="addition">+BOARD_PLS_COMPATIBLE := false</span></span><br><span class="line"><span class="addition">+endif</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>c/c++代码,同样定义变量   <blockquote>
<p>NATIVE_DISPLAY_NAME_CAMERA_VENDOR\<native\> = “alcatel”   </native\></p>
</blockquote>
</li>
</ol>
<p>再修改代码引用<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/idh.code/vendor/sprd/modules/libcamera/oem2v0/src/cmr_setting.c</span></span><br><span class="line"><span class="comment">+++ b/idh.code/vendor/sprd/modules/libcamera/oem2v0/src/cmr_setting.c</span></span><br><span class="line"><span class="meta">@@ -26,7 +26,7 @@</span></span><br><span class="line"> #include "sensor_drv_u.h"</span><br><span class="line"> #include "cmr_exif.h"</span><br><span class="line"> #include "cmr_oem.h"</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+#include \&lt;android/spr_target.h\&gt;</span></span><br><span class="line"> </span><br><span class="line"> #define SETTING_MSG_QUEUE_SIZE              5</span><br><span class="line"> </span><br><span class="line">@@ -1506,11 +1506,15 @@ static cmr_int setting_get_exif_info(struct setting_component *cpt,</span><br><span class="line">     strcpy((char *)p_exif_info-\&gt;primary.img_desc_ptr-\&gt;ImageDescription, (char *)image_desc);</span><br><span class="line">     memset(property,'\0',sizeof(property));</span><br><span class="line">     property_get("ro.product.manufacturer", property, EXIF_DEF_MAKER);</span><br><span class="line"><span class="deletion">-    strcpy((char *)p_exif_info-\&gt;primary.img_desc_ptr-\&gt;Make, (char *)property);</span></span><br><span class="line"><span class="addition">+    //SPROCOMM</span></span><br><span class="line"><span class="addition">+    //strcpy((char *)p_exif_info-\&gt;primary.img_desc_ptr-\&gt;Make, (char *)property);</span></span><br><span class="line"><span class="addition">+    strcpy((char *)p_exif_info-\&gt;primary.img_desc_ptr-\&gt;Make, NATIVE_DISPLAY_NAME_CAMERA_VENDOR);</span></span><br><span class="line">     </span><br><span class="line">     memset(property,'\0',sizeof(property));</span><br><span class="line">     property_get("ro.product.model", property, EXIF_DEF_MODEL);</span><br></pre></td></tr></table></figure></p>
<p>或者定义:</p>
<blockquote>
<p>SUPPORT_OTG\<define\> = 0;<br>那spr_target.h代码中将生成:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUPPORT_OTG_UNDEFINED</span></span><br></pre></td></tr></table></figure></define\></p>
<p>SUPPORT_OTG\<define\> = 1;(或者”true”/“yes”)<br>那spr_target.h代码中将生成:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUPPORT_OTG</span></span><br></pre></td></tr></table></figure></define\></p>
</blockquote>
<h2 id="Android应用资源文件的覆盖规则"><a href="#Android应用资源文件的覆盖规则" class="headerlink" title="Android应用资源文件的覆盖规则"></a>Android应用资源文件的覆盖规则</h2><p>我们在Android上层开发时经常会遇到替换图标/壁纸/布局/字符,串等资源,Android编译系统提供了两个变量(DEVICE_PACKAGE_OVERLAYS/PRODUCT_PACKAGE_OVERLAYS)可以控制资源文件的覆盖问题(AndroidManifest.xml不支持这种覆盖方式),我们创建了一个目录<code>vendor/sprocomm_overlays/$(MODULES_PROJECT_NAME)</code>放置这些要覆盖的文件,在全编或者单编时会自动引用该文件夹下的文件而无需拷贝(图片和布局这类一个文件生成一个R.java中id的文件需要保持文件名不变,字符串这类一个变量生成一个id的则可以为文件随便命名)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAVE_SPR_OVERLAY_FILE := $(shell test -d vendor/sprocomm_overlays/$(MODULES_PROJECT_NAME) &amp;&amp; echo yes)  </span><br><span class="line">ifeq ($(strip $(HAVE_SPR_OVERLAY_FILE)),yes)</span><br><span class="line">    $(warning &apos;Including sprocomm overlays&apos;) </span><br><span class="line">    PRODUCT_PACKAGE_OVERLAYS += \</span><br><span class="line">        vendor/sprocomm_overlays/$(MODULES_PROJECT_NAME)</span><br><span class="line">else</span><br><span class="line">    $(warning &apos;No sprocomm overlays&apos;) </span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<p>如我想替换X50142的Setting的图标,那么将新的图标文件放在:<code>vendor/sprocomm_overlays/X50142/packages/apps/Settings/res/mipmap-hdpi/ic_launcher_settings.png</code></p>
<p>如我想修改Chrome浏览器的主页和书签,那么我可以创建一个xml(<strong>文件名任意</strong>)放置在<code>vendor/sprocomm_overlays/X50142/packages/providers/PartnerBookmarksProvider/res/values/overlay_bookmarks.xml</code>,文件内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意此处,我们并没有覆盖bookmarks_folder_name,那么bookmarks_folder_name将使用原来的值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--string name="bookmarks_folder_name" translatable="false"&gt;Partner Bookmarks&lt;/string--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们并不关注homepage这个字符串原来是定义到哪个xml文件中的,我们只要写在这里就能生效 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"homepage"</span> <span class="attr">translatable</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        http://www.alcatel-mobile.com<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Bookmarks icon--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"bookmark_preloads"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bookmarks --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">"bookmarks"</span> <span class="attr">translatable</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>My Onetouch<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>http://3g.my-onetouch.com<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>Alcatel Store<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>http://shop.alcatel-mobile.com<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同样的我们还可以用这种方法修改系统framework/base/core/res/values/configs.xml或者SettingProvider中的配置而无需覆盖整个文件</p>
<p>另外如果我们需要为X50142项目在Settings<code>/res/raw</code>文件夹中添加一个新文件xx.ogg,我们只需要将xx.ogg放在<code>vendor/sprocomm_overlays/X50142/packages/apps/Settings/res/raw</code>文件夹下,这样编译别的项目时就不会把这个文件编译进去,减小APK体积</p>
<p>个人墙裂建议把spec中定义的SettingProvider中的各个默认值移除用这种方式来覆盖(1. 尊重Android原始设计,避免代码混乱 2. 减少因为spec中添加变量导致的需要重新全编问题)</p>
<h1 id="SPROCOMM-Android项目编译命令"><a href="#SPROCOMM-Android项目编译命令" class="headerlink" title="SPROCOMM Android项目编译命令"></a>SPROCOMM Android项目编译命令</h1><h2 id="全编译"><a href="#全编译" class="headerlink" title="全编译"></a>全编译</h2><p>当安装好环境并下载代码后，通常需要将整套代码完整编译一次, 编译脚本一般有两个<code>buildall_user.sh</code>,<code>buildall_eng.sh</code>，前者用于编译发布给客户的版本，后者用于编译研发自己使用的版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./buildall_eng.sh X4568LV snod pac</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中:</p>
<ul>
<li>X4568LV : 项目名</li>
<li><code>pac</code>   : 打包参数，用于将编译生成的img文件打包成下载工具可以识别的文件格式</li>
<li>其他参数(如<code>./buildall_eng.sh X4568LV snod</code>直接打包生成system.img)请直接运行<code>buildall_eng.sh</code>查看帮助提示</li>
</ul>
</blockquote>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./make_pac.sh X4568LV</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用于将编译生成的文件手动打包为下载工具可以识别的文件格式</p>
<p>完整编译时会在代码根目录下生成一个文件夹或压缩包，其中包含当前代码的git版本号，和编译过程中产生的log，以及用于后期调试需要的vmlinux备份文件。 当编译失败时，需要检查其中的<code>build.log</code>或<code>buildOta.log</code> 根据log排除编译错误</p>
</blockquote>
<h2 id="单编模块"><a href="#单编模块" class="headerlink" title="单编模块"></a>单编模块</h2><p>修改了一个模块的代码后需要编译验证，在一个新的终端中第一次单编时需要先导入环境变量(单编user版本的模块需要用buildall_user.sh)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> buildall_eng.sh X4568LV env</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>实际是将<code>source build/envsetup.sh</code>等命令批量运行了一遍<br>导入环境变量时注意全编的是哪个项目(以及什么版本),如果与全编时不一致很可能会自动删除掉out目录下的一些文件,导致需要重新全编译(新版本的脚本检测到不一致时会提示)</p>
</blockquote>
<p>导入环境变量后就可以单独编译模块了</p>
<ul>
<li><code>mm</code>  单编当前目录的模块</li>
<li><code>mmm &lt;module_path&gt;</code> 单编<code>&lt;module_path&gt;</code>路径所指向的模块</li>
<li>单编完成后会在<code>out/target/product/xxxxx/system/</code>目录对于的文件夹下生成编译好的模块，可以安装或push到手机中验证</li>
<li>推送文件到手机需要使用<code>adb</code>命令，请参考ADB章节</li>
</ul>
<h1 id="编译错误处理"><a href="#编译错误处理" class="headerlink" title="编译错误处理"></a>编译错误处理</h1><ol>
<li>GC overhead limit exceeded </li>
<li>OOM</li>
</ol>
<blockquote>
<p>Try increasing heap size with Java option ‘-Xmx’<br>解决方法：<a href="http://blog.csdn.net/brightming/article/details/49763515" target="_blank" rel="noopener">http://blog.csdn.net/brightming/article/details/49763515</a><br>修改 prebuilts/sdk/tools/jack-admin<br>在下面这行中，增加 -Xmx4096m<br>JACK_SERVER_COMMAND=”java -Djava.io.tmpdir=$TMPDIR$JACK_SERVER_VM_ARGUMENTS -Xmx4096m -cp $LAUNCHER_JAR</p>
</blockquote>
<ol>
<li><p>提示adb.iso 文件找不到导致编译失败, 需要系统中安装 mkisofs , genisoimage</p>
<blockquote>
<p>sudo apt-get install genisoimage</p>
</blockquote>
</li>
<li><p>提示”WARNING!!! can’t find board directory [device/sprd/scx20_/sp7731c<em>1h10</em>]”, 特点是<code>scx20_</code>和<code>sp7731c_1h10_</code>后面有个下划线</p>
<blockquote>
<p>原因是Windows系统中的换行符比linux多一个<code>&quot;\r&quot;</code>,需要用文本编辑器删除</p>
</blockquote>
</li>
<li><p>语法正确的Makefile（xxx.mk） 在编译时提示”xxxxxxx <em>*</em> missing separator. “</p>
<blockquote>
<p>原因也是Windows换行符,需要删除<code>&quot;\r&quot;</code></p>
</blockquote>
</li>
<li><p>6.0和7.0都可能遇到的Can’t Launch Jack.</p>
<blockquote>
<p>Jack服务可能时由于内存等原因没有启动,重新编译一次即可</p>
</blockquote>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/sTeAbC" target="_blank" rel="noopener">http://www.jianshu.com/p/sTeAbC</a></li>
<li><a href="http://blog.csdn.net/lizekun2010/article/details/52598105" target="_blank" rel="noopener">http://blog.csdn.net/lizekun2010/article/details/52598105</a></li>
<li>BOOK: Embedded Android</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/Git常用指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/13/Git常用指令/" itemprop="url">Git常用指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-13T22:07:18+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h3><ul>
<li><img src="http://i.imgur.com/vM452Xj.png" alt=""><ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区</li>
<li>Remote：远程仓库</li>
</ul>
</li>
</ul>
<hr>
<ol>
<li><p>新建代码库</p>
<ul>
<li>在当前目录新建一个Git代码库<ul>
<li><strong>git init</strong></li>
</ul>
</li>
<li>新建一个目录，将其初始化为Git代码库<ul>
<li><strong>git init [project-name]</strong></li>
</ul>
</li>
<li>复制一个项目和它的整个代码历史<ul>
<li><strong>git clone [url]</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>配置</p>
<ul>
<li>分为全局配置和项目配置 <strong>.git</strong>文件</li>
<li>显示当前的Git配置<ul>
<li><strong>git config –list</strong></li>
</ul>
</li>
<li>编辑Git配置文件<ul>
<li><strong>git config -e [–global]</strong></li>
</ul>
</li>
<li><strong>git config [–global] user.name ‘[name]’</strong></li>
<li><strong>git config [–global] user.email ‘[email]’</strong></li>
</ul>
</li>
<li><p>增加、删除文件</p>
<ul>
<li>添加指定文件到暂存区<ul>
<li><strong>git add [file1] [file2] …</strong></li>
</ul>
</li>
<li>添加指定目录到暂存区，包括子目录<ul>
<li><strong>git add [dir]</strong></li>
</ul>
</li>
<li>添加当前目录的所有文件到暂存区<ul>
<li><strong>git add .</strong></li>
</ul>
</li>
<li>添加每个变化前，都会要求确认，对于同一个文件的多出变化可以实现分次提交<ul>
<li><strong>git add -p</strong></li>
</ul>
</li>
<li>删除工作区文件，并且将这次删除放入暂存区<ul>
<li><strong>git rm [file1] [file2] …</strong></li>
</ul>
</li>
<li>停止追踪指定文件，但该文件会保留在工作区<ul>
<li><strong>git rm –cached [file]</strong></li>
</ul>
</li>
<li>改名文件，并且将这个改名放入暂存区<ul>
<li><strong>git mv [file-original] [file-renamed]</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>代码提交</p>
<ul>
<li>提交暂存区到仓库区<ul>
<li><strong>git commit -m [message]</strong></li>
</ul>
</li>
<li>提交暂存区的指定文件到仓库区<ul>
<li><strong>git commit [file1] [file2] … -m [message]</strong></li>
</ul>
</li>
<li>提交工作区自上次commit之后的变化，直接到仓库区<ul>
<li><strong>git commit -a</strong></li>
</ul>
</li>
<li>提交时显示所有diff信息<ul>
<li><strong>git commit -v</strong></li>
</ul>
</li>
<li>使用一次新的commit，代替上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息<ul>
<li><strong>git commit –amend -m [message]</strong>：</li>
</ul>
</li>
<li>重做上一次commit，并包括指定文件的新变化<ul>
<li><strong>git commit –amend [file1] [file2] …</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>分支</p>
<ul>
<li>列出所有本地分支<ul>
<li><strong>git branch</strong></li>
</ul>
</li>
<li>列出所有远程分支<ul>
<li><strong>git branch -r</strong></li>
</ul>
</li>
<li>列出所有本地和远程分支<ul>
<li><strong>git branch -a</strong></li>
</ul>
</li>
<li>新建一个分支，但依然停留在当前分支<ul>
<li><strong>git branch [branch-name]</strong></li>
</ul>
</li>
<li>新建一个分支，并且切换到该分支<ul>
<li><strong>git checkout -b [branch]</strong></li>
</ul>
</li>
<li>新建一个分支，指向指定commit<ul>
<li><strong>git branch [branch] [commit]</strong></li>
</ul>
</li>
<li>新建一个分支，与指定的远程分支建立追踪关系<ul>
<li><strong>git branch –track [branch] [remote-branch]</strong>：</li>
</ul>
</li>
<li>切换到指定分支，并更新工作区<ul>
<li><strong>git checkout [branch-name]</strong></li>
</ul>
</li>
<li>切换到上一分支<ul>
<li><strong>git checkout -</strong></li>
</ul>
</li>
<li>建立追踪关系，与现有分支与指定的远程分支之间<ul>
<li><strong>git branch –set -upstream [branch] [remote-branch]</strong></li>
</ul>
</li>
<li>合并指定分支到当前分支<ul>
<li><strong>git merge [branch]</strong></li>
</ul>
</li>
<li>选择一个commit，合并进当前分支<ul>
<li><strong>git cherry-pick [commit]</strong></li>
</ul>
</li>
<li>删除分支<ul>
<li><strong>git branch -d [branch-name]</strong></li>
</ul>
</li>
<li>删除远程分支<ul>
<li><strong>git push origin –delete [branch-name]</strong></li>
<li><strong>git branch -dr [remote/branch]</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>标签</p>
<ul>
<li>列出所有tag    <ul>
<li><strong>git tag</strong></li>
</ul>
</li>
<li>新建一个tag在当前commit<ul>
<li><strong>git tag [tag]</strong></li>
</ul>
</li>
<li>新建一个tag在指定commit<ul>
<li><strong>git tag [tag] [commit]</strong></li>
</ul>
</li>
<li>删除本地tag<ul>
<li><strong>git tag -d [tag]</strong></li>
</ul>
</li>
<li>删除远程tag<ul>
<li><strong>git push origin :refs/tags/[tagName]</strong></li>
</ul>
</li>
<li>查看tag信息<ul>
<li><strong>git show [tag]</strong></li>
</ul>
</li>
<li>提交指定tag<ul>
<li><strong>git push [remote] [tag]</strong></li>
</ul>
</li>
<li>提交所有tag<ul>
<li><strong>git push [remote] –tags</strong></li>
</ul>
</li>
<li>新建一个分支，指向某个tag<ul>
<li><strong>git checkout -b [branch] [tag]</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>查看信息</p>
<ul>
<li>显示有变更的文件<ul>
<li><strong>git status</strong></li>
</ul>
</li>
<li>显示当前分支的版本历史<ul>
<li><strong>git log</strong></li>
</ul>
</li>
<li>显示commit历史，以及每次commit发生变更的文件<ul>
<li><strong>git log –stat</strong></li>
</ul>
</li>
<li>搜索提交历史，根据关键词<ul>
<li><strong>git log -S [keyword]</strong></li>
</ul>
</li>
<li>显示某个commit之后的所有变动，每个commit占据一行<ul>
<li><strong>git log [tag] HEAD –pretty=format:%s</strong></li>
</ul>
</li>
<li>显示某个commite之后的所有变动，其“提交说明”必须符合搜索条件<ul>
<li><strong>git log [tag] HEAD –grep feature</strong></li>
</ul>
</li>
<li>显示某个文件的版本历史，包括文件改名<ul>
<li><strong>git log –follow [file]</strong></li>
<li><strong>git whatchanged [file]</strong></li>
</ul>
</li>
<li>显示指定文件相关的每一次diff<ul>
<li><strong>git log -p [file]</strong></li>
</ul>
</li>
<li>显示过去5次提交<ul>
<li><strong>git log -5 –pretty –oneline</strong></li>
</ul>
</li>
<li>显示所有提交过的用户，按提交次数排序<ul>
<li><strong>git shortlog -sn</strong></li>
</ul>
</li>
<li>显示指定文件是什么人在什么时间修改过<ul>
<li><strong>git blame [file]</strong></li>
</ul>
</li>
<li>显示暂存区和工作区的差异<ul>
<li><strong>git diff</strong></li>
</ul>
</li>
<li>显示暂存区和上一个commit的差异<ul>
<li><strong>git diff –cached [file]</strong></li>
</ul>
</li>
<li>显示工作区与当前分支最新commit之间的差异<ul>
<li><strong>git diff HEAD</strong></li>
</ul>
</li>
<li>显示两次提交之间的差异<ul>
<li><strong>git diff [first-branch]…[second-branch]</strong></li>
</ul>
</li>
<li>显示今天你写了多少行代码<ul>
<li><strong>git diff –shortstat “@{0 day ago}”</strong></li>
</ul>
</li>
<li>显示某次提交的元数据和内容变化<ul>
<li><strong>git show [commit]</strong></li>
</ul>
</li>
<li>显示某次提交发生变化的文件<ul>
<li><strong>git show –name-only [commit]</strong></li>
</ul>
</li>
<li>显示某次提交时，某个文件的内容<ul>
<li><strong>git show [commit]:[filename]</strong></li>
</ul>
</li>
<li>显示当前分支的最近几次提交<ul>
<li><strong>git reflog</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>远程同步</p>
<ul>
<li>下载远程仓库的所有变动<ul>
<li><strong>git fetch [remote]</strong></li>
</ul>
</li>
<li>显示所有远程仓库<ul>
<li><strong>git remote -v</strong></li>
</ul>
</li>
<li>显示某个远程仓库的信息<ul>
<li><strong>git remote show [remote]</strong></li>
</ul>
</li>
<li>增加一个新的远程仓库，并命名<ul>
<li><strong>git remote add [shortname] [url]</strong></li>
</ul>
</li>
<li>取回远程仓库的变化，并与本地分支合并<ul>
<li><strong>git pull [remote] [branch]</strong></li>
</ul>
</li>
<li>上传本地指定分支到远程仓库<ul>
<li><strong>git push [remote] [branch]</strong></li>
</ul>
</li>
<li>强行推送当前分支到远程仓库，即使有冲突<ul>
<li><strong>git push [remote] –force</strong></li>
</ul>
</li>
<li>推送所有分支到远程仓库<ul>
<li><strong>git push [remote] –all</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>撤销</p>
<ul>
<li>恢复暂存区的指定文件到工作区<ul>
<li><strong>git checkout [file]</strong></li>
</ul>
</li>
<li>恢复某个commit的指定文件到暂存区和工作区<ul>
<li><strong>git checkout [commit] [file]</strong></li>
</ul>
</li>
<li>恢复暂存区的所有文件到工作区<ul>
<li><strong>git checkout .</strong></li>
</ul>
</li>
<li>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<ul>
<li><strong>git reset [file]</strong></li>
</ul>
</li>
<li>重置暂存区与工作区，与上一次commit保持一致<ul>
<li><strong>git reset –hard</strong></li>
</ul>
</li>
<li>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<ul>
<li><strong>git reset [commit]</strong></li>
</ul>
</li>
<li>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<ul>
<li><strong>git reset –hard [commit]</strong></li>
</ul>
</li>
<li>重置当前HEAD为指定commit，但保持暂存区和工作区不变<ul>
<li><strong>git reset –keep [commit]</strong></li>
</ul>
</li>
<li>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支<ul>
<li><strong>git revert [commit]</strong></li>
</ul>
</li>
<li>暂时将未提交的变化移除，稍后再移入<ul>
<li><strong>git stash</strong></li>
<li><strong>git stash pop</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>生成一个可供发布的压缩包<ul>
<li><strong>git archive</strong></li>
</ul>
</li>
<li>grep查找<ul>
<li>git grep [-n显示行号] xxxx</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/2017-03-10-Launcher3基础-adb命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JamesWong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JamesWong's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/2017-03-10-Launcher3基础-adb命令/" itemprop="url">Launcher3基础 adb命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T10:17:40+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017-3-10-10-17"><a href="#2017-3-10-10-17" class="headerlink" title="2017/3/10 10:17"></a>2017/3/10 10:17</h2><p>##### </p>
<h2 id="今日概要"><a href="#今日概要" class="headerlink" title="今日概要"></a>今日概要</h2><ol>
<li><strong>回顾昨日知识点</strong></li>
<li><strong>了解Launcher</strong></li>
<li><strong>adb命令</strong></li>
</ol>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h3><ol>
<li>Framework启动Launcher流程<ul>
<li><img src="http://i.imgur.com/4yLgYys.png" alt=""></li>
</ul>
</li>
<li>PackageManger管理类<ul>
<li>负责管理应用程序包，可以通过它获取应用程序信息，通过getPacageManager方法得到这个类</li>
<li>ResolveInfo：这个类是通过解析一个与IntentFilter相对应的intent得到的信息。它部分地对应于从AndroidManifest.xml的<intent>标签收集到的信息。</intent></li>
</ul>
</li>
<li>简易LauncherDemo步骤<ol>
<li>搭建两个布局：主界面（GridView）、item布局（图标、app名称）</li>
<li>Launcher.java<ol>
<li>获取PackageManger</li>
<li>通过action获取intent<ul>
<li>Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);<br>mainIntent.addCategory(Intent.CATEGORY_LAUNCHER); </li>
</ul>
</li>
<li>根据intent查处所有app信息<ul>
<li>mAllApps = mPackageManager.queryIntentActivities(mainIntent, 0); </li>
</ul>
</li>
<li>设置到GridView上</li>
<li>给item添加点击时间<ul>
<li>通过ResoveInfo获取目标app的包名和入口Activity</li>
<li>用ComponentName启动app</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>CellLayout：存放大小不一的控件</li>
</ol>
<h3 id="adb命令-Android-Debug-Bridge"><a href="#adb命令-Android-Debug-Bridge" class="headerlink" title="adb命令(Android Debug Bridge)"></a>adb命令(Android Debug Bridge)</h3><ol>
<li>常用命令<ul>
<li>查看设备<ul>
<li>adb devices</li>
</ul>
</li>
<li>安装apk<ul>
<li>adb install [-r重新安装，-s安装到sd卡] [路径]</li>
</ul>
</li>
<li>卸载软件<ul>
<li>adb uninstall [-k删除配置和缓存] [软件名com.jameswong.demo]</li>
</ul>
</li>
<li>进入设备或模拟器的shell<ul>
<li>adb shell</li>
<li>adb shell [command]：adb shell dmesg会打印出内核的调试信息</li>
</ul>
</li>
<li>从电脑发送文件到设备<ul>
<li>adb push [本地路径] [远程路径]</li>
</ul>
</li>
<li>从设备下载文件到电脑<ul>
<li>adb pull [远程路径] [本地路径]</li>
</ul>
</li>
<li>查看bug报告<ul>
<li>adb bugreport</li>
</ul>
</li>
<li>启动Server<ul>
<li>adb start-server</li>
</ul>
</li>
<li>停止Server<ul>
<li>adb kill-server</li>
</ul>
</li>
<li>清除应用数据与缓存<ul>
<li>adb shell pm clear [packagename]</li>
</ul>
</li>
<li>启动应用<ul>
<li>adb shell am start -n com.stormzhang.demo/.ui.SplashActivity</li>
</ul>
</li>
<li>强制停止应用<ul>
<li>adb shell am force-stop <packagename></packagename></li>
</ul>
</li>
<li>查看日志<ul>
<li>adb logcat</li>
</ul>
</li>
<li>重启<ul>
<li>adb reboot</li>
</ul>
</li>
<li>获取root权限<ul>
<li>adb root</li>
</ul>
</li>
<li>重新挂载系统分区<ul>
<li>adb remount</li>
</ul>
</li>
<li>获取序列号<ul>
<li>adb get-serialno</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li><strong>Dalvik</strong>与<strong>ART(Android runtime)</strong><ul>
<li>Google公司自己设计用于Android平台的Java虚拟机</li>
<li>2014年Google I/O 删除Dalvik，用<strong>ART</strong>替代</li>
<li>区别<ul>
<li><img src="http://i.imgur.com/Z8BJ9HI.png" alt=""></li>
<li><strong>ART模式</strong>：是Android runtime的简称。在ART虚拟机环境下，Android对程序只进行一次编译，就是在程序安装时。在安装应用时，ART虚拟机就先将程序的Java语言转化为适合Android系统运行的机器语言，而且是一次编译终身受用。这样就免于程序每次运行时，都要重新编译的麻烦了，系统的运行效率被大大提高。</li>
<li><strong>Dalvik</strong>：是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。它可以支持已转换为 .dex（即Dalvik Executable）格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且[1] 每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</li>
</ul>
</li>
</ul>
</li>
<li>onAttachedToWindow()是在onResume()方法之后执行</li>
<li>View中的onFinishInflate()方法<ul>
<li>当View中所有的子控件均被映射成xml后触发，即MyView mv = (MyView)View.inflate (context,R.layout.my_view,null);之后执行</li>
</ul>
</li>
<li>AS查找快捷键<ul>
<li>Ctrl+F：在当前窗口查找文本</li>
<li>Ctrl+Shift+F：在当前工程内查找文本</li>
<li>Ctrl+N：查找类</li>
<li>Ctrl+Shift+N：查找文件</li>
<li>Ctrl+Shift+Alt+N：查找项目中的方法或变量</li>
<li>光标停留类名，右键”Find Usages”(快捷键Alt+F7)：查找类/方法/变量引用的地方</li>
<li>ctrl+F7：该方法在当前类中的被使用到的地方</li>
<li>Ctrl+F12：在类中快速定位某个方法或属性</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JamesWong</p>
              <p class="site-description motion-element" itemprop="description">简单即快乐。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JamesWong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
